/************************************************************************************
 *  File name: mumessage.c
 *  Modified: 22 November 2017
 *  Author:  Christopher Crary
 *  Purpose: Source file for MuMessage, a built-in messaging application for MuPhone.
************************************************************************************/

/////////////////////////////////DEPENDENCIES////////////////////////////////////////
#include "mumessage.h"
#include "G8RTOS.h"
#include "LCD.h"     // QUESTION: what is the best way to include LCD.h?
#include "GPIO.h"    // QUESTION: what is the best way to include GPIO.h?

/////////////////////////////END OF DEPENDENCIES/////////////////////////////////////

////////////////////////////////////DEFINES//////////////////////////////////////////

/* MISCELLANEOUS MUMESSAGE DEFINES */

// wait until active-low LCD TouchPanel reads a high voltage
#define TOUCHPANEL_WAIT()   while(!(P4->IN & BIT0))

////////////////////////////////END OF DEFINES///////////////////////////////////////

////////////////////////////////////EXTERNS//////////////////////////////////////////

extern semaphore_t semaphore_CC3100;          // used to access CC3100 WiFi chip


////////////////////////////////END OF EXTERNS///////////////////////////////////////

//////////////////////////////PUBLIC DATA MEMBERS////////////////////////////////////
//////////////////////////END OF PUBLIC DATA MEMBERS/////////////////////////////////

//////////////////////////////PRIVATE DATA MEMBERS///////////////////////////////////


/* message notification image */
const uint8_t message_notification_icon_data[20][20] = {
                                        { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
                                        { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
                                        { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
                                        { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
                                        { 182, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 182},
                                        { 182, 145, 145, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 182, 145, 182},
                                        { 182, 145, 182, 145, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 250, 145, 182, 182},
                                        { 182, 145, 255, 182, 145, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 250, 145, 250, 182, 182},
                                        { 182, 145, 255, 255, 145, 145, 250, 255, 255, 255, 255, 255, 255, 255, 250, 145, 250, 255, 182, 182},
                                        { 182, 145, 255, 255, 250, 145, 145, 250, 255, 255, 255, 255, 255, 250, 145, 250, 255, 255, 182, 182},
                                        { 182, 145, 250, 250, 250, 250, 145, 145, 250, 250, 250, 250, 182, 145, 250, 250, 250, 250, 182, 182},
                                        { 182, 145, 250, 250, 250, 250, 145, 145, 182, 250, 250, 182, 145, 145, 182, 250, 250, 250, 182, 182},
                                        { 182, 145, 250, 250, 250, 145, 182, 250, 145, 145, 145, 145, 182, 250, 145, 182, 250, 250, 182, 182},
                                        { 182, 145, 250, 250, 145, 182, 250, 250, 250, 250, 250, 250, 250, 250, 250, 145, 182, 250, 182, 182},
                                        { 182, 145, 182, 145, 182, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 145, 145, 182, 182},
                                        { 182, 145, 145, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 182, 145, 182},
                                        { 182, 145, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 145, 182},
                                        { 182, 145, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 145, 182},
                                        { 250, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 250},
                                        { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
                                    };


/* main screen */

const Rectangle section_mumessage_main_screen[] =
{
     {MUMESSAGE_MAIN_SCREEN_X_MIN, MUMESSAGE_MAIN_SCREEN_X_MAX, MUMESSAGE_MAIN_SCREEN_Y_MIN, MUMESSAGE_MAIN_SCREEN_Y_MAX,
      MUMESSAGE_MAIN_SCREEN_COLOR}
};
const Rectangle section_mumessage_main_screen_buttons[] =
{
     {MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_X_MIN, MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_X_MAX,
      MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_Y_MIN, MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_Y_MAX,
      MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_COLOR},
     {MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_X_MIN, MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_X_MAX,
      MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_Y_MIN, MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_Y_MAX,
      MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_COLOR}
};

const Text text_section_mumessage_main_screen[] =
{
 {MUMESSAGE_MAIN_SCREEN_INTRO_TEXT_X_START, MUMESSAGE_MAIN_SCREEN_INTRO_TEXT_Y_START,
  " MuMessage: an embedded messaging app~n"
  "Created by Brit Chesley and Chris Crary",
  MUMESSAGE_MAIN_SCREEN_INTRO_TEXT_COLOR},
 {MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_TEXT_X_START, MUMESSAGE_MAIN_SCREEN_COMPOSE_MESSAGE_BUTTON_TEXT_Y_START,
  "Compose Message", MUMESSAGE_MAIN_SCREEN_BUTTON_TEXT_COLOR},
  {MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_TEXT_X_START, MUMESSAGE_MAIN_SCREEN_MESSAGE_LOG_BUTTON_TEXT_Y_START,
    "Message Log", MUMESSAGE_MAIN_SCREEN_BUTTON_TEXT_COLOR}
};

/************************** COMPOSE MESSAGE MEMBERS ********************************/

/* sections used to draw Compose Message and used to check for touches made
 * to the LCD TouchPanel */

// compose message background section
const static Rectangle section_compose_message_background[] =
{
    {COMPOSE_MESSAGE_BACKGROUND_X_MIN, COMPOSE_MESSAGE_BACKGROUND_X_MAX,
     COMPOSE_MESSAGE_BACKGROUND_Y_MIN, COMPOSE_MESSAGE_BACKGROUND_Y_MAX,
     COMPOSE_MESSAGE_BACKGROUND_COLOR}
};

// compose message header bar
const static Rectangle section_compose_message_header[] =
{
    {COMPOSE_MESSAGE_HEADER_X_MIN, COMPOSE_MESSAGE_HEADER_X_MAX,
     COMPOSE_MESSAGE_HEADER_Y_MIN, COMPOSE_MESSAGE_HEADER_Y_MAX,
     COMPOSE_MESSAGE_HEADER_COLOR},
    {COMPOSE_MESSAGE_HEADER_DIVIDER_X_MIN, COMPOSE_MESSAGE_HEADER_DIVIDER_X_MAX,
     COMPOSE_MESSAGE_HEADER_DIVIDER_Y_MIN, COMPOSE_MESSAGE_HEADER_DIVIDER_Y_MAX,
     COMPOSE_MESSAGE_HEADER_DIVIDER_COLOR}
};

// compose message header bar buttons (back/send)
const static Rectangle section_compose_message_header_buttons[] =
{
     {COMPOSE_MESSAGE_BACK_BUTTON_X_MIN, COMPOSE_MESSAGE_BACK_BUTTON_X_MAX,
      COMPOSE_MESSAGE_BACK_BUTTON_Y_MIN, COMPOSE_MESSAGE_BACK_BUTTON_Y_MAX,
      COMPOSE_MESSAGE_BACK_BUTTON_COLOR},
     {COMPOSE_MESSAGE_SEND_BUTTON_X_MIN, COMPOSE_MESSAGE_SEND_BUTTON_X_MAX,
      COMPOSE_MESSAGE_SEND_BUTTON_Y_MIN, COMPOSE_MESSAGE_SEND_BUTTON_Y_MAX,
      COMPOSE_MESSAGE_SEND_BUTTON_COLOR}
};

// compose message header buttons text
const static Text text_section_compose_message_header[] =
{
     {COMPOSE_MESSAGE_BACK_BUTTON_TEXT_X_START, COMPOSE_MESSAGE_BACK_BUTTON_TEXT_Y_START,
      "< BACK", COMPOSE_MESSAGE_BACK_BUTTON_TEXT_COLOR},
     {COMPOSE_MESSAGE_SEND_BUTTON_TEXT_X_START, COMPOSE_MESSAGE_SEND_BUTTON_TEXT_Y_START,
      "SEND MESSAGE", COMPOSE_MESSAGE_SEND_BUTTON_TEXT_COLOR}
};

// text arena background section
const static Rectangle section_text_arena[] =
{
     {TEXT_ARENA_X_MIN, TEXT_ARENA_X_MAX, TEXT_ARENA_Y_MIN, TEXT_ARENA_Y_MAX, COMPOSE_MESSAGE_TEXT_ARENA_COLOR}
};

// keyboard background section
const static Rectangle section_keyboard_background[] =
{
    {KEYBOARD_DIVIDER_X_MIN, KEYBOARD_DIVIDER_X_MAX,
     KEYBOARD_DIVIDER_Y_MIN, KEYBOARD_DIVIDER_Y_MAX,
     KEYBOARD_DIVIDER_COLOR},
    {KEYBOARD_X_MIN, KEYBOARD_X_MAX, KEYBOARD_Y_MIN, KEYBOARD_Y_MAX, KEYBOARD_COLOR}
};

// keyboard #1 (no click) (lower-case keyboard)
const static Rectangle section_keyboard1_no_click[] =
{
     {LOWERCASE_Q_BUTTON_X_MIN, LOWERCASE_Q_BUTTON_X_MAX, LOWERCASE_Q_BUTTON_Y_MIN, LOWERCASE_Q_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                        // row 1 of 4
     {LOWERCASE_W_BUTTON_X_MIN, LOWERCASE_W_BUTTON_X_MAX, LOWERCASE_W_BUTTON_Y_MIN, LOWERCASE_W_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_E_BUTTON_X_MIN, LOWERCASE_E_BUTTON_X_MAX, LOWERCASE_E_BUTTON_Y_MIN, LOWERCASE_E_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_R_BUTTON_X_MIN, LOWERCASE_R_BUTTON_X_MAX, LOWERCASE_R_BUTTON_Y_MIN, LOWERCASE_R_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_T_BUTTON_X_MIN, LOWERCASE_T_BUTTON_X_MAX, LOWERCASE_T_BUTTON_Y_MIN, LOWERCASE_T_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_Y_BUTTON_X_MIN, LOWERCASE_Y_BUTTON_X_MAX, LOWERCASE_Y_BUTTON_Y_MIN, LOWERCASE_Y_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_U_BUTTON_X_MIN, LOWERCASE_U_BUTTON_X_MAX, LOWERCASE_U_BUTTON_Y_MIN, LOWERCASE_U_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_I_BUTTON_X_MIN, LOWERCASE_I_BUTTON_X_MAX, LOWERCASE_I_BUTTON_Y_MIN, LOWERCASE_I_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_O_BUTTON_X_MIN, LOWERCASE_O_BUTTON_X_MAX, LOWERCASE_O_BUTTON_Y_MIN, LOWERCASE_O_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_P_BUTTON_X_MIN, LOWERCASE_P_BUTTON_X_MAX, LOWERCASE_P_BUTTON_Y_MIN, LOWERCASE_P_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_A_BUTTON_X_MIN, LOWERCASE_A_BUTTON_X_MAX, LOWERCASE_A_BUTTON_Y_MIN, LOWERCASE_A_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                        // row 2 of 4
     {LOWERCASE_S_BUTTON_X_MIN, LOWERCASE_S_BUTTON_X_MAX, LOWERCASE_S_BUTTON_Y_MIN, LOWERCASE_S_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_D_BUTTON_X_MIN, LOWERCASE_D_BUTTON_X_MAX, LOWERCASE_D_BUTTON_Y_MIN, LOWERCASE_D_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_F_BUTTON_X_MIN, LOWERCASE_F_BUTTON_X_MAX, LOWERCASE_F_BUTTON_Y_MIN, LOWERCASE_F_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_G_BUTTON_X_MIN, LOWERCASE_G_BUTTON_X_MAX, LOWERCASE_G_BUTTON_Y_MIN, LOWERCASE_G_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_H_BUTTON_X_MIN, LOWERCASE_H_BUTTON_X_MAX, LOWERCASE_H_BUTTON_Y_MIN, LOWERCASE_H_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_J_BUTTON_X_MIN, LOWERCASE_J_BUTTON_X_MAX, LOWERCASE_J_BUTTON_Y_MIN, LOWERCASE_J_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_K_BUTTON_X_MIN, LOWERCASE_K_BUTTON_X_MAX, LOWERCASE_K_BUTTON_Y_MIN, LOWERCASE_K_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_L_BUTTON_X_MIN, LOWERCASE_L_BUTTON_X_MAX, LOWERCASE_L_BUTTON_Y_MIN, LOWERCASE_L_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD1_CHANGE_CASE_BUTTON_X_MIN, KEYBOARD1_CHANGE_CASE_BUTTON_X_MAX, KEYBOARD1_CHANGE_CASE_BUTTON_Y_MIN,                                                                   // row 3 of 4
      KEYBOARD1_CHANGE_CASE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_Z_BUTTON_X_MIN, LOWERCASE_Z_BUTTON_X_MAX, LOWERCASE_Z_BUTTON_Y_MIN, LOWERCASE_Z_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_X_BUTTON_X_MIN, LOWERCASE_X_BUTTON_X_MAX, LOWERCASE_X_BUTTON_Y_MIN, LOWERCASE_X_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_C_BUTTON_X_MIN, LOWERCASE_C_BUTTON_X_MAX, LOWERCASE_C_BUTTON_Y_MIN, LOWERCASE_C_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_V_BUTTON_X_MIN, LOWERCASE_V_BUTTON_X_MAX, LOWERCASE_V_BUTTON_Y_MIN, LOWERCASE_V_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_B_BUTTON_X_MIN, LOWERCASE_B_BUTTON_X_MAX, LOWERCASE_B_BUTTON_Y_MIN, LOWERCASE_B_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_N_BUTTON_X_MIN, LOWERCASE_N_BUTTON_X_MAX, LOWERCASE_N_BUTTON_Y_MIN, LOWERCASE_N_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LOWERCASE_M_BUTTON_X_MIN, LOWERCASE_M_BUTTON_X_MAX, LOWERCASE_M_BUTTON_Y_MIN, LOWERCASE_M_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD1_BACKSPACE_BUTTON_X_MIN, KEYBOARD1_BACKSPACE_BUTTON_X_MAX, KEYBOARD1_BACKSPACE_BUTTON_Y_MIN,
      KEYBOARD1_BACKSPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MIN, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MAX, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MIN,                        // row 4 of 4
      KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD1_SPACE_BUTTON_X_MIN, KEYBOARD1_SPACE_BUTTON_X_MAX, KEYBOARD1_SPACE_BUTTON_Y_MIN,
      KEYBOARD1_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD1_RETURN_BUTTON_X_MIN, KEYBOARD1_RETURN_BUTTON_X_MAX, KEYBOARD1_RETURN_BUTTON_Y_MIN,
      KEYBOARD1_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR}
};

// keyboard #1 (no click) text
const static Text text_section_keyboard1_no_click[] =
{
     {LOWERCASE_Q_BUTTON_TEXT_X_START, LOWERCASE_Q_BUTTON_TEXT_Y_START, "q", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                        // row 1 of 4
     {LOWERCASE_W_BUTTON_TEXT_X_START, LOWERCASE_W_BUTTON_TEXT_Y_START, "w", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_E_BUTTON_TEXT_X_START, LOWERCASE_E_BUTTON_TEXT_Y_START, "e", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_R_BUTTON_TEXT_X_START, LOWERCASE_R_BUTTON_TEXT_Y_START, "r", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_T_BUTTON_TEXT_X_START, LOWERCASE_T_BUTTON_TEXT_Y_START, "t", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_Y_BUTTON_TEXT_X_START, LOWERCASE_Y_BUTTON_TEXT_Y_START, "y", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_U_BUTTON_TEXT_X_START, LOWERCASE_U_BUTTON_TEXT_Y_START, "u", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_I_BUTTON_TEXT_X_START, LOWERCASE_I_BUTTON_TEXT_Y_START, "i", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_O_BUTTON_TEXT_X_START, LOWERCASE_O_BUTTON_TEXT_Y_START, "o", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_P_BUTTON_TEXT_X_START, LOWERCASE_P_BUTTON_TEXT_Y_START, "p", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_A_BUTTON_TEXT_X_START, LOWERCASE_A_BUTTON_TEXT_Y_START, "a", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                        // row 2 of 4
     {LOWERCASE_S_BUTTON_TEXT_X_START, LOWERCASE_S_BUTTON_TEXT_Y_START, "s", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_D_BUTTON_TEXT_X_START, LOWERCASE_D_BUTTON_TEXT_Y_START, "d", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_F_BUTTON_TEXT_X_START, LOWERCASE_F_BUTTON_TEXT_Y_START, "f", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_G_BUTTON_TEXT_X_START, LOWERCASE_G_BUTTON_TEXT_Y_START, "g", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_H_BUTTON_TEXT_X_START, LOWERCASE_H_BUTTON_TEXT_Y_START, "h", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_J_BUTTON_TEXT_X_START, LOWERCASE_J_BUTTON_TEXT_Y_START, "j", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_K_BUTTON_TEXT_X_START, LOWERCASE_K_BUTTON_TEXT_Y_START, "k", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_L_BUTTON_TEXT_X_START, LOWERCASE_L_BUTTON_TEXT_Y_START, "l", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD1_CHANGE_CASE_BUTTON_TEXT_X_START, KEYBOARD1_CHANGE_CASE_BUTTON_TEXT_Y_START, "~^|", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                 // row 3 of 4
     {LOWERCASE_Z_BUTTON_TEXT_X_START, LOWERCASE_Z_BUTTON_TEXT_Y_START, "z", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_X_BUTTON_TEXT_X_START, LOWERCASE_X_BUTTON_TEXT_Y_START, "x", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_C_BUTTON_TEXT_X_START, LOWERCASE_C_BUTTON_TEXT_Y_START, "c", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_V_BUTTON_TEXT_X_START, LOWERCASE_V_BUTTON_TEXT_Y_START, "v", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_B_BUTTON_TEXT_X_START, LOWERCASE_B_BUTTON_TEXT_Y_START, "b", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_N_BUTTON_TEXT_X_START, LOWERCASE_N_BUTTON_TEXT_Y_START, "n", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {LOWERCASE_M_BUTTON_TEXT_X_START, LOWERCASE_M_BUTTON_TEXT_Y_START, "m", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD1_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD1_BACKSPACE_BUTTON_TEXT_Y_START, "<X", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_X_START, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                // row 4 of 4
     {KEYBOARD1_SPACE_BUTTON_TEXT_X_START, KEYBOARD1_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD1_RETURN_BUTTON_TEXT_X_START, KEYBOARD1_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR}
};

// keyboard #1 (click) (lower-case keyboard)
const static Rectangle section_keyboard1_click[] =
{
     {LOWERCASE_Q_BUTTON_X_MIN, LOWERCASE_Q_BUTTON_X_MAX, LOWERCASE_Q_BUTTON_Y_MIN, LOWERCASE_Q_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                        // row 1 of 4
     {LOWERCASE_W_BUTTON_X_MIN, LOWERCASE_W_BUTTON_X_MAX, LOWERCASE_W_BUTTON_Y_MIN, LOWERCASE_W_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_E_BUTTON_X_MIN, LOWERCASE_E_BUTTON_X_MAX, LOWERCASE_E_BUTTON_Y_MIN, LOWERCASE_E_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_R_BUTTON_X_MIN, LOWERCASE_R_BUTTON_X_MAX, LOWERCASE_R_BUTTON_Y_MIN, LOWERCASE_R_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_T_BUTTON_X_MIN, LOWERCASE_T_BUTTON_X_MAX, LOWERCASE_T_BUTTON_Y_MIN, LOWERCASE_T_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_Y_BUTTON_X_MIN, LOWERCASE_Y_BUTTON_X_MAX, LOWERCASE_Y_BUTTON_Y_MIN, LOWERCASE_Y_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_U_BUTTON_X_MIN, LOWERCASE_U_BUTTON_X_MAX, LOWERCASE_U_BUTTON_Y_MIN, LOWERCASE_U_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_I_BUTTON_X_MIN, LOWERCASE_I_BUTTON_X_MAX, LOWERCASE_I_BUTTON_Y_MIN, LOWERCASE_I_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_O_BUTTON_X_MIN, LOWERCASE_O_BUTTON_X_MAX, LOWERCASE_O_BUTTON_Y_MIN, LOWERCASE_O_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_P_BUTTON_X_MIN, LOWERCASE_P_BUTTON_X_MAX, LOWERCASE_P_BUTTON_Y_MIN, LOWERCASE_P_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_A_BUTTON_X_MIN, LOWERCASE_A_BUTTON_X_MAX, LOWERCASE_A_BUTTON_Y_MIN, LOWERCASE_A_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                        // row 2 of 4
     {LOWERCASE_S_BUTTON_X_MIN, LOWERCASE_S_BUTTON_X_MAX, LOWERCASE_S_BUTTON_Y_MIN, LOWERCASE_S_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_D_BUTTON_X_MIN, LOWERCASE_D_BUTTON_X_MAX, LOWERCASE_D_BUTTON_Y_MIN, LOWERCASE_D_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_F_BUTTON_X_MIN, LOWERCASE_F_BUTTON_X_MAX, LOWERCASE_F_BUTTON_Y_MIN, LOWERCASE_F_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_G_BUTTON_X_MIN, LOWERCASE_G_BUTTON_X_MAX, LOWERCASE_G_BUTTON_Y_MIN, LOWERCASE_G_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_H_BUTTON_X_MIN, LOWERCASE_H_BUTTON_X_MAX, LOWERCASE_H_BUTTON_Y_MIN, LOWERCASE_H_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_J_BUTTON_X_MIN, LOWERCASE_J_BUTTON_X_MAX, LOWERCASE_J_BUTTON_Y_MIN, LOWERCASE_J_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_K_BUTTON_X_MIN, LOWERCASE_K_BUTTON_X_MAX, LOWERCASE_K_BUTTON_Y_MIN, LOWERCASE_K_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_L_BUTTON_X_MIN, LOWERCASE_L_BUTTON_X_MAX, LOWERCASE_L_BUTTON_Y_MIN, LOWERCASE_L_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD1_CHANGE_CASE_BUTTON_X_MIN, KEYBOARD1_CHANGE_CASE_BUTTON_X_MAX, KEYBOARD1_CHANGE_CASE_BUTTON_Y_MIN,                                                                   // row 3 of 4
      KEYBOARD1_CHANGE_CASE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_BOLD_COLOR},
     {LOWERCASE_Z_BUTTON_X_MIN, LOWERCASE_Z_BUTTON_X_MAX, LOWERCASE_Z_BUTTON_Y_MIN, LOWERCASE_Z_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_X_BUTTON_X_MIN, LOWERCASE_X_BUTTON_X_MAX, LOWERCASE_X_BUTTON_Y_MIN, LOWERCASE_X_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_C_BUTTON_X_MIN, LOWERCASE_C_BUTTON_X_MAX, LOWERCASE_C_BUTTON_Y_MIN, LOWERCASE_C_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_V_BUTTON_X_MIN, LOWERCASE_V_BUTTON_X_MAX, LOWERCASE_V_BUTTON_Y_MIN, LOWERCASE_V_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_B_BUTTON_X_MIN, LOWERCASE_B_BUTTON_X_MAX, LOWERCASE_B_BUTTON_Y_MIN, LOWERCASE_B_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_N_BUTTON_X_MIN, LOWERCASE_N_BUTTON_X_MAX, LOWERCASE_N_BUTTON_Y_MIN, LOWERCASE_N_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {LOWERCASE_M_BUTTON_X_MIN, LOWERCASE_M_BUTTON_X_MAX, LOWERCASE_M_BUTTON_Y_MIN, LOWERCASE_M_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD1_BACKSPACE_BUTTON_X_MIN, KEYBOARD1_BACKSPACE_BUTTON_X_MAX, KEYBOARD1_BACKSPACE_BUTTON_Y_MIN,
      KEYBOARD1_BACKSPACE_BUTTON_Y_MAX, COMPOSE_MESSAGE_BACKSPACE_BUTTON_CLICK_COLOR},
     {KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MIN, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MAX, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MIN,                        // row 4 of 4
      KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD1_SPACE_BUTTON_X_MIN, KEYBOARD1_SPACE_BUTTON_X_MAX, KEYBOARD1_SPACE_BUTTON_Y_MIN,
      KEYBOARD1_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD1_RETURN_BUTTON_X_MIN, KEYBOARD1_RETURN_BUTTON_X_MAX, KEYBOARD1_RETURN_BUTTON_Y_MIN,
      KEYBOARD1_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR}
};

// keyboard #1 text
const static Text text_section_keyboard1_click[] =
{
     {LOWERCASE_Q_BUTTON_TEXT_X_START, LOWERCASE_Q_BUTTON_TEXT_Y_START, "q", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                        // row 1 of 4
     {LOWERCASE_W_BUTTON_TEXT_X_START, LOWERCASE_W_BUTTON_TEXT_Y_START, "w", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_E_BUTTON_TEXT_X_START, LOWERCASE_E_BUTTON_TEXT_Y_START, "e", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_R_BUTTON_TEXT_X_START, LOWERCASE_R_BUTTON_TEXT_Y_START, "r", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_T_BUTTON_TEXT_X_START, LOWERCASE_T_BUTTON_TEXT_Y_START, "t", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_Y_BUTTON_TEXT_X_START, LOWERCASE_Y_BUTTON_TEXT_Y_START, "y", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_U_BUTTON_TEXT_X_START, LOWERCASE_U_BUTTON_TEXT_Y_START, "u", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_I_BUTTON_TEXT_X_START, LOWERCASE_I_BUTTON_TEXT_Y_START, "i", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_O_BUTTON_TEXT_X_START, LOWERCASE_O_BUTTON_TEXT_Y_START, "o", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_P_BUTTON_TEXT_X_START, LOWERCASE_P_BUTTON_TEXT_Y_START, "p", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_A_BUTTON_TEXT_X_START, LOWERCASE_A_BUTTON_TEXT_Y_START, "a", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                        // row 2 of 4
     {LOWERCASE_S_BUTTON_TEXT_X_START, LOWERCASE_S_BUTTON_TEXT_Y_START, "s", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_D_BUTTON_TEXT_X_START, LOWERCASE_D_BUTTON_TEXT_Y_START, "d", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_F_BUTTON_TEXT_X_START, LOWERCASE_F_BUTTON_TEXT_Y_START, "f", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_G_BUTTON_TEXT_X_START, LOWERCASE_G_BUTTON_TEXT_Y_START, "g", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_H_BUTTON_TEXT_X_START, LOWERCASE_H_BUTTON_TEXT_Y_START, "h", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_J_BUTTON_TEXT_X_START, LOWERCASE_J_BUTTON_TEXT_Y_START, "j", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_K_BUTTON_TEXT_X_START, LOWERCASE_K_BUTTON_TEXT_Y_START, "k", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_L_BUTTON_TEXT_X_START, LOWERCASE_L_BUTTON_TEXT_Y_START, "l", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD1_CHANGE_CASE_BUTTON_TEXT_X_START, KEYBOARD1_CHANGE_CASE_BUTTON_TEXT_Y_START, "~^|", COMPOSE_MESSAGE_UPPERCASE_BUTTON_TEXT_CLICK_COLOR},                 // row 3 of 4
     {LOWERCASE_Z_BUTTON_TEXT_X_START, LOWERCASE_Z_BUTTON_TEXT_Y_START, "z", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_X_BUTTON_TEXT_X_START, LOWERCASE_X_BUTTON_TEXT_Y_START, "x", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_C_BUTTON_TEXT_X_START, LOWERCASE_C_BUTTON_TEXT_Y_START, "c", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_V_BUTTON_TEXT_X_START, LOWERCASE_V_BUTTON_TEXT_Y_START, "v", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_B_BUTTON_TEXT_X_START, LOWERCASE_B_BUTTON_TEXT_Y_START, "b", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_N_BUTTON_TEXT_X_START, LOWERCASE_N_BUTTON_TEXT_Y_START, "n", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {LOWERCASE_M_BUTTON_TEXT_X_START, LOWERCASE_M_BUTTON_TEXT_Y_START, "m", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD1_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD1_BACKSPACE_BUTTON_TEXT_Y_START, "<X", COMPOSE_MESSAGE_BACKSPACE_BUTTON_TEXT_CLICK_COLOR},
     {KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_X_START, KEYBOARD1_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_CLICK_COLOR},                // row 4 of 4
     {KEYBOARD1_SPACE_BUTTON_TEXT_X_START, KEYBOARD1_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD1_RETURN_BUTTON_TEXT_X_START, KEYBOARD1_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_CLICK_COLOR}
};


// keyboard #2 (no click) (upper-case keyboard)
const static Rectangle section_keyboard2_no_click[] =
{
     {UPPERCASE_Q_BUTTON_X_MIN, UPPERCASE_Q_BUTTON_X_MAX, UPPERCASE_Q_BUTTON_Y_MIN, UPPERCASE_Q_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                        // row 1 of 4
     {UPPERCASE_W_BUTTON_X_MIN, UPPERCASE_W_BUTTON_X_MAX, UPPERCASE_W_BUTTON_Y_MIN, UPPERCASE_W_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_E_BUTTON_X_MIN, UPPERCASE_E_BUTTON_X_MAX, UPPERCASE_E_BUTTON_Y_MIN, UPPERCASE_E_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_R_BUTTON_X_MIN, UPPERCASE_R_BUTTON_X_MAX, UPPERCASE_R_BUTTON_Y_MIN, UPPERCASE_R_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_T_BUTTON_X_MIN, UPPERCASE_T_BUTTON_X_MAX, UPPERCASE_T_BUTTON_Y_MIN, UPPERCASE_T_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_Y_BUTTON_X_MIN, UPPERCASE_Y_BUTTON_X_MAX, UPPERCASE_Y_BUTTON_Y_MIN, UPPERCASE_Y_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_U_BUTTON_X_MIN, UPPERCASE_U_BUTTON_X_MAX, UPPERCASE_U_BUTTON_Y_MIN, UPPERCASE_U_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_I_BUTTON_X_MIN, UPPERCASE_I_BUTTON_X_MAX, UPPERCASE_I_BUTTON_Y_MIN, UPPERCASE_I_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_O_BUTTON_X_MIN, UPPERCASE_O_BUTTON_X_MAX, UPPERCASE_O_BUTTON_Y_MIN, UPPERCASE_O_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_P_BUTTON_X_MIN, UPPERCASE_P_BUTTON_X_MAX, UPPERCASE_P_BUTTON_Y_MIN, UPPERCASE_P_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_A_BUTTON_X_MIN, UPPERCASE_A_BUTTON_X_MAX, UPPERCASE_A_BUTTON_Y_MIN, UPPERCASE_A_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                        // row 2 of 4
     {UPPERCASE_S_BUTTON_X_MIN, UPPERCASE_S_BUTTON_X_MAX, UPPERCASE_S_BUTTON_Y_MIN, UPPERCASE_S_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_D_BUTTON_X_MIN, UPPERCASE_D_BUTTON_X_MAX, UPPERCASE_D_BUTTON_Y_MIN, UPPERCASE_D_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_F_BUTTON_X_MIN, UPPERCASE_F_BUTTON_X_MAX, UPPERCASE_F_BUTTON_Y_MIN, UPPERCASE_F_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_G_BUTTON_X_MIN, UPPERCASE_G_BUTTON_X_MAX, UPPERCASE_G_BUTTON_Y_MIN, UPPERCASE_G_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_H_BUTTON_X_MIN, UPPERCASE_H_BUTTON_X_MAX, UPPERCASE_H_BUTTON_Y_MIN, UPPERCASE_H_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_J_BUTTON_X_MIN, UPPERCASE_J_BUTTON_X_MAX, UPPERCASE_J_BUTTON_Y_MIN, UPPERCASE_J_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_K_BUTTON_X_MIN, UPPERCASE_K_BUTTON_X_MAX, UPPERCASE_K_BUTTON_Y_MIN, UPPERCASE_K_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_L_BUTTON_X_MIN, UPPERCASE_L_BUTTON_X_MAX, UPPERCASE_L_BUTTON_Y_MIN, UPPERCASE_L_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD2_CHANGE_CASE_BUTTON_X_MIN, KEYBOARD2_CHANGE_CASE_BUTTON_X_MAX, KEYBOARD1_CHANGE_CASE_BUTTON_Y_MIN,                                                                   // row 3 of 4
      KEYBOARD2_CHANGE_CASE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_BOLD_COLOR},
     {UPPERCASE_Z_BUTTON_X_MIN, UPPERCASE_Z_BUTTON_X_MAX, UPPERCASE_Z_BUTTON_Y_MIN, UPPERCASE_Z_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_X_BUTTON_X_MIN, UPPERCASE_X_BUTTON_X_MAX, UPPERCASE_X_BUTTON_Y_MIN, UPPERCASE_X_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_C_BUTTON_X_MIN, UPPERCASE_C_BUTTON_X_MAX, UPPERCASE_C_BUTTON_Y_MIN, UPPERCASE_C_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_V_BUTTON_X_MIN, UPPERCASE_V_BUTTON_X_MAX, UPPERCASE_V_BUTTON_Y_MIN, UPPERCASE_V_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_B_BUTTON_X_MIN, UPPERCASE_B_BUTTON_X_MAX, UPPERCASE_B_BUTTON_Y_MIN, UPPERCASE_B_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_N_BUTTON_X_MIN, UPPERCASE_N_BUTTON_X_MAX, UPPERCASE_N_BUTTON_Y_MIN, UPPERCASE_N_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UPPERCASE_M_BUTTON_X_MIN, UPPERCASE_M_BUTTON_X_MAX, UPPERCASE_M_BUTTON_Y_MIN, UPPERCASE_M_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD2_BACKSPACE_BUTTON_X_MIN, KEYBOARD2_BACKSPACE_BUTTON_X_MAX, KEYBOARD2_BACKSPACE_BUTTON_Y_MIN,
      KEYBOARD2_BACKSPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MIN, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MAX, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MIN,                        // row 4 of 4
      KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD2_SPACE_BUTTON_X_MIN, KEYBOARD2_SPACE_BUTTON_X_MAX, KEYBOARD2_SPACE_BUTTON_Y_MIN,
      KEYBOARD2_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD2_RETURN_BUTTON_X_MIN, KEYBOARD2_RETURN_BUTTON_X_MAX, KEYBOARD2_RETURN_BUTTON_Y_MIN,
      KEYBOARD2_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR}
};

// keyboard #2 (no click) text
const static Text text_section_keyboard2_no_click[] =
{
     {UPPERCASE_Q_BUTTON_TEXT_X_START, UPPERCASE_Q_BUTTON_TEXT_Y_START, "Q", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                        // row 1 of 4
     {UPPERCASE_W_BUTTON_TEXT_X_START, UPPERCASE_W_BUTTON_TEXT_Y_START, "W", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_E_BUTTON_TEXT_X_START, UPPERCASE_E_BUTTON_TEXT_Y_START, "E", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_R_BUTTON_TEXT_X_START, UPPERCASE_R_BUTTON_TEXT_Y_START, "R", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_T_BUTTON_TEXT_X_START, UPPERCASE_T_BUTTON_TEXT_Y_START, "T", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_Y_BUTTON_TEXT_X_START, UPPERCASE_Y_BUTTON_TEXT_Y_START, "Y", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_U_BUTTON_TEXT_X_START, UPPERCASE_U_BUTTON_TEXT_Y_START, "U", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_I_BUTTON_TEXT_X_START, UPPERCASE_I_BUTTON_TEXT_Y_START, "I", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_O_BUTTON_TEXT_X_START, UPPERCASE_O_BUTTON_TEXT_Y_START, "O", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_P_BUTTON_TEXT_X_START, UPPERCASE_P_BUTTON_TEXT_Y_START, "P", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_A_BUTTON_TEXT_X_START, UPPERCASE_A_BUTTON_TEXT_Y_START, "A", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                        // row 2 of 4
     {UPPERCASE_S_BUTTON_TEXT_X_START, UPPERCASE_S_BUTTON_TEXT_Y_START, "S", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_D_BUTTON_TEXT_X_START, UPPERCASE_D_BUTTON_TEXT_Y_START, "D", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_F_BUTTON_TEXT_X_START, UPPERCASE_F_BUTTON_TEXT_Y_START, "F", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_G_BUTTON_TEXT_X_START, UPPERCASE_G_BUTTON_TEXT_Y_START, "G", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_H_BUTTON_TEXT_X_START, UPPERCASE_H_BUTTON_TEXT_Y_START, "H", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_J_BUTTON_TEXT_X_START, UPPERCASE_J_BUTTON_TEXT_Y_START, "J", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_K_BUTTON_TEXT_X_START, UPPERCASE_K_BUTTON_TEXT_Y_START, "K", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_L_BUTTON_TEXT_X_START, UPPERCASE_L_BUTTON_TEXT_Y_START, "L", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD2_CHANGE_CASE_BUTTON_TEXT_X_START, KEYBOARD2_CHANGE_CASE_BUTTON_TEXT_Y_START, "~^|", COMPOSE_MESSAGE_UPPERCASE_BUTTON_TEXT_CLICK_COLOR},                 // row 3 of 4
     {UPPERCASE_Z_BUTTON_TEXT_X_START, UPPERCASE_Z_BUTTON_TEXT_Y_START, "Z", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_X_BUTTON_TEXT_X_START, UPPERCASE_X_BUTTON_TEXT_Y_START, "X", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_C_BUTTON_TEXT_X_START, UPPERCASE_C_BUTTON_TEXT_Y_START, "C", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_V_BUTTON_TEXT_X_START, UPPERCASE_V_BUTTON_TEXT_Y_START, "V", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_B_BUTTON_TEXT_X_START, UPPERCASE_B_BUTTON_TEXT_Y_START, "B", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_N_BUTTON_TEXT_X_START, UPPERCASE_N_BUTTON_TEXT_Y_START, "N", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {UPPERCASE_M_BUTTON_TEXT_X_START, UPPERCASE_M_BUTTON_TEXT_Y_START, "M", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD2_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD2_BACKSPACE_BUTTON_TEXT_Y_START, "<X", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_X_START, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                // row 4 of 4
     {KEYBOARD2_SPACE_BUTTON_TEXT_X_START, KEYBOARD2_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD2_RETURN_BUTTON_TEXT_X_START, KEYBOARD2_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR}
};

// keyboard #2 (click) (upper-case keyboard)
const static Rectangle section_keyboard2_click[] =
{
     {UPPERCASE_Q_BUTTON_X_MIN, UPPERCASE_Q_BUTTON_X_MAX, UPPERCASE_Q_BUTTON_Y_MIN, UPPERCASE_Q_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                        // row 1 of 4
     {UPPERCASE_W_BUTTON_X_MIN, UPPERCASE_W_BUTTON_X_MAX, UPPERCASE_W_BUTTON_Y_MIN, UPPERCASE_W_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_E_BUTTON_X_MIN, UPPERCASE_E_BUTTON_X_MAX, UPPERCASE_E_BUTTON_Y_MIN, UPPERCASE_E_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_R_BUTTON_X_MIN, UPPERCASE_R_BUTTON_X_MAX, UPPERCASE_R_BUTTON_Y_MIN, UPPERCASE_R_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_T_BUTTON_X_MIN, UPPERCASE_T_BUTTON_X_MAX, UPPERCASE_T_BUTTON_Y_MIN, UPPERCASE_T_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_Y_BUTTON_X_MIN, UPPERCASE_Y_BUTTON_X_MAX, UPPERCASE_Y_BUTTON_Y_MIN, UPPERCASE_Y_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_U_BUTTON_X_MIN, UPPERCASE_U_BUTTON_X_MAX, UPPERCASE_U_BUTTON_Y_MIN, UPPERCASE_U_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_I_BUTTON_X_MIN, UPPERCASE_I_BUTTON_X_MAX, UPPERCASE_I_BUTTON_Y_MIN, UPPERCASE_I_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_O_BUTTON_X_MIN, UPPERCASE_O_BUTTON_X_MAX, UPPERCASE_O_BUTTON_Y_MIN, UPPERCASE_O_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_P_BUTTON_X_MIN, UPPERCASE_P_BUTTON_X_MAX, UPPERCASE_P_BUTTON_Y_MIN, UPPERCASE_P_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_A_BUTTON_X_MIN, UPPERCASE_A_BUTTON_X_MAX, UPPERCASE_A_BUTTON_Y_MIN, UPPERCASE_A_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                        // row 2 of 4
     {UPPERCASE_S_BUTTON_X_MIN, UPPERCASE_S_BUTTON_X_MAX, UPPERCASE_S_BUTTON_Y_MIN, UPPERCASE_S_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_D_BUTTON_X_MIN, UPPERCASE_D_BUTTON_X_MAX, UPPERCASE_D_BUTTON_Y_MIN, UPPERCASE_D_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_F_BUTTON_X_MIN, UPPERCASE_F_BUTTON_X_MAX, UPPERCASE_F_BUTTON_Y_MIN, UPPERCASE_F_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_G_BUTTON_X_MIN, UPPERCASE_G_BUTTON_X_MAX, UPPERCASE_G_BUTTON_Y_MIN, UPPERCASE_G_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_H_BUTTON_X_MIN, UPPERCASE_H_BUTTON_X_MAX, UPPERCASE_H_BUTTON_Y_MIN, UPPERCASE_H_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_J_BUTTON_X_MIN, UPPERCASE_J_BUTTON_X_MAX, UPPERCASE_J_BUTTON_Y_MIN, UPPERCASE_J_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_K_BUTTON_X_MIN, UPPERCASE_K_BUTTON_X_MAX, UPPERCASE_K_BUTTON_Y_MIN, UPPERCASE_K_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_L_BUTTON_X_MIN, UPPERCASE_L_BUTTON_X_MAX, UPPERCASE_L_BUTTON_Y_MIN, UPPERCASE_L_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD2_CHANGE_CASE_BUTTON_X_MIN, KEYBOARD2_CHANGE_CASE_BUTTON_X_MAX, KEYBOARD1_CHANGE_CASE_BUTTON_Y_MIN,                                                                   // row 3 of 4
      KEYBOARD2_CHANGE_CASE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_BOLD_COLOR},
     {UPPERCASE_Z_BUTTON_X_MIN, UPPERCASE_Z_BUTTON_X_MAX, UPPERCASE_Z_BUTTON_Y_MIN, UPPERCASE_Z_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_X_BUTTON_X_MIN, UPPERCASE_X_BUTTON_X_MAX, UPPERCASE_X_BUTTON_Y_MIN, UPPERCASE_X_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_C_BUTTON_X_MIN, UPPERCASE_C_BUTTON_X_MAX, UPPERCASE_C_BUTTON_Y_MIN, UPPERCASE_C_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_V_BUTTON_X_MIN, UPPERCASE_V_BUTTON_X_MAX, UPPERCASE_V_BUTTON_Y_MIN, UPPERCASE_V_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_B_BUTTON_X_MIN, UPPERCASE_B_BUTTON_X_MAX, UPPERCASE_B_BUTTON_Y_MIN, UPPERCASE_B_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_N_BUTTON_X_MIN, UPPERCASE_N_BUTTON_X_MAX, UPPERCASE_N_BUTTON_Y_MIN, UPPERCASE_N_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {UPPERCASE_M_BUTTON_X_MIN, UPPERCASE_M_BUTTON_X_MAX, UPPERCASE_M_BUTTON_Y_MIN, UPPERCASE_M_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD2_BACKSPACE_BUTTON_X_MIN, KEYBOARD2_BACKSPACE_BUTTON_X_MAX, KEYBOARD2_BACKSPACE_BUTTON_Y_MIN,
      KEYBOARD2_BACKSPACE_BUTTON_Y_MAX, COMPOSE_MESSAGE_BACKSPACE_BUTTON_CLICK_COLOR},
     {KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MIN, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_X_MAX, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MIN,                        // row 4 of 4
      KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD2_SPACE_BUTTON_X_MIN, KEYBOARD2_SPACE_BUTTON_X_MAX, KEYBOARD2_SPACE_BUTTON_Y_MIN,
      KEYBOARD2_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD2_RETURN_BUTTON_X_MIN, KEYBOARD2_RETURN_BUTTON_X_MAX, KEYBOARD2_RETURN_BUTTON_Y_MIN,
      KEYBOARD2_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR}
};

// keyboard #2 (click) text
const static Text text_section_keyboard2_click[] =
{
     {UPPERCASE_Q_BUTTON_TEXT_X_START, UPPERCASE_Q_BUTTON_TEXT_Y_START, "Q", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                        // row 1 of 4
     {UPPERCASE_W_BUTTON_TEXT_X_START, UPPERCASE_W_BUTTON_TEXT_Y_START, "W", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_E_BUTTON_TEXT_X_START, UPPERCASE_E_BUTTON_TEXT_Y_START, "E", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_R_BUTTON_TEXT_X_START, UPPERCASE_R_BUTTON_TEXT_Y_START, "R", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_T_BUTTON_TEXT_X_START, UPPERCASE_T_BUTTON_TEXT_Y_START, "T", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_Y_BUTTON_TEXT_X_START, UPPERCASE_Y_BUTTON_TEXT_Y_START, "Y", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_U_BUTTON_TEXT_X_START, UPPERCASE_U_BUTTON_TEXT_Y_START, "U", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_I_BUTTON_TEXT_X_START, UPPERCASE_I_BUTTON_TEXT_Y_START, "I", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_O_BUTTON_TEXT_X_START, UPPERCASE_O_BUTTON_TEXT_Y_START, "O", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_P_BUTTON_TEXT_X_START, UPPERCASE_P_BUTTON_TEXT_Y_START, "P", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_A_BUTTON_TEXT_X_START, UPPERCASE_A_BUTTON_TEXT_Y_START, "A", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                        // row 2 of 4
     {UPPERCASE_S_BUTTON_TEXT_X_START, UPPERCASE_S_BUTTON_TEXT_Y_START, "S", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_D_BUTTON_TEXT_X_START, UPPERCASE_D_BUTTON_TEXT_Y_START, "D", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_F_BUTTON_TEXT_X_START, UPPERCASE_F_BUTTON_TEXT_Y_START, "F", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_G_BUTTON_TEXT_X_START, UPPERCASE_G_BUTTON_TEXT_Y_START, "G", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_H_BUTTON_TEXT_X_START, UPPERCASE_H_BUTTON_TEXT_Y_START, "H", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_J_BUTTON_TEXT_X_START, UPPERCASE_J_BUTTON_TEXT_Y_START, "J", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_K_BUTTON_TEXT_X_START, UPPERCASE_K_BUTTON_TEXT_Y_START, "K", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_L_BUTTON_TEXT_X_START, UPPERCASE_L_BUTTON_TEXT_Y_START, "L", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD2_CHANGE_CASE_BUTTON_TEXT_X_START, KEYBOARD2_CHANGE_CASE_BUTTON_TEXT_Y_START, "~^|", COMPOSE_MESSAGE_UPPERCASE_BUTTON_TEXT_CLICK_COLOR},                 // row 3 of 4
     {UPPERCASE_Z_BUTTON_TEXT_X_START, UPPERCASE_Z_BUTTON_TEXT_Y_START, "Z", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_X_BUTTON_TEXT_X_START, UPPERCASE_X_BUTTON_TEXT_Y_START, "X", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_C_BUTTON_TEXT_X_START, UPPERCASE_C_BUTTON_TEXT_Y_START, "C", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_V_BUTTON_TEXT_X_START, UPPERCASE_V_BUTTON_TEXT_Y_START, "V", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_B_BUTTON_TEXT_X_START, UPPERCASE_B_BUTTON_TEXT_Y_START, "B", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_N_BUTTON_TEXT_X_START, UPPERCASE_N_BUTTON_TEXT_Y_START, "N", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {UPPERCASE_M_BUTTON_TEXT_X_START, UPPERCASE_M_BUTTON_TEXT_Y_START, "M", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD2_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD2_BACKSPACE_BUTTON_TEXT_Y_START, "<X", COMPOSE_MESSAGE_BACKSPACE_BUTTON_TEXT_CLICK_COLOR},
     {KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_X_START, KEYBOARD2_CHANGE_TO_NUMBERS_SYMBOLS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_CLICK_COLOR},                // row 4 of 4
     {KEYBOARD2_SPACE_BUTTON_TEXT_X_START, KEYBOARD2_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD2_RETURN_BUTTON_TEXT_X_START, KEYBOARD2_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_CLICK_COLOR}
};

// keyboard #3 (no click)
const static Rectangle section_keyboard3_no_click[] =
{
     {NUM_1_BUTTON_X_MIN, NUM_1_BUTTON_X_MAX, NUM_1_BUTTON_Y_MIN, NUM_1_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                               // row 1 of 4
     {NUM_2_BUTTON_X_MIN, NUM_2_BUTTON_X_MAX, NUM_2_BUTTON_Y_MIN, NUM_2_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_3_BUTTON_X_MIN, NUM_3_BUTTON_X_MAX, NUM_3_BUTTON_Y_MIN, NUM_3_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_4_BUTTON_X_MIN, NUM_4_BUTTON_X_MAX, NUM_4_BUTTON_Y_MIN, NUM_4_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_5_BUTTON_X_MIN, NUM_5_BUTTON_X_MAX, NUM_5_BUTTON_Y_MIN, NUM_5_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_6_BUTTON_X_MIN, NUM_6_BUTTON_X_MAX, NUM_6_BUTTON_Y_MIN, NUM_6_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_7_BUTTON_X_MIN, NUM_7_BUTTON_X_MAX, NUM_7_BUTTON_Y_MIN, NUM_7_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_8_BUTTON_X_MIN, NUM_8_BUTTON_X_MAX, NUM_8_BUTTON_Y_MIN, NUM_8_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_9_BUTTON_X_MIN, NUM_9_BUTTON_X_MAX, NUM_9_BUTTON_Y_MIN, NUM_9_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUM_0_BUTTON_X_MIN, NUM_0_BUTTON_X_MAX, NUM_0_BUTTON_Y_MIN, NUM_0_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {DASH_BUTTON_X_MIN, DASH_BUTTON_X_MAX, DASH_BUTTON_Y_MIN, DASH_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                   // row 2 of 4
     {FORWARD_SLASH_BUTTON_X_MIN, FORWARD_SLASH_BUTTON_X_MAX, FORWARD_SLASH_BUTTON_Y_MIN, FORWARD_SLASH_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {COLON_BUTTON_X_MIN, COLON_BUTTON_X_MAX, COLON_BUTTON_Y_MIN, COLON_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {SEMICOLON_BUTTON_X_MIN, SEMICOLON_BUTTON_X_MAX, SEMICOLON_BUTTON_Y_MIN, SEMICOLON_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {OPENING_PAREN_BUTTON_X_MIN, OPENING_PAREN_BUTTON_X_MAX, OPENING_PAREN_BUTTON_Y_MIN, OPENING_PAREN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {CLOSING_PAREN_BUTTON_X_MIN, CLOSING_PAREN_BUTTON_X_MAX, CLOSING_PAREN_BUTTON_Y_MIN, CLOSING_PAREN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {DOLLAR_SIGN_BUTTON_X_MIN, DOLLAR_SIGN_BUTTON_X_MAX, DOLLAR_SIGN_BUTTON_Y_MIN, DOLLAR_SIGN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {AMPERSAND_BUTTON_X_MIN, AMPERSAND_BUTTON_X_MAX, AMPERSAND_BUTTON_Y_MIN, AMPERSAND_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {AT_BUTTON_X_MIN, AT_BUTTON_X_MAX, AT_BUTTON_Y_MIN, AT_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {DOUBLE_QUOTE_BUTTON_X_MIN, DOUBLE_QUOTE_BUTTON_X_MAX, DOUBLE_QUOTE_BUTTON_Y_MIN, DOUBLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {SYMBOLS_BUTTON_X_MIN, SYMBOLS_BUTTON_X_MAX, SYMBOLS_BUTTON_Y_MIN, SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                       // row 3 of 4
     {KEYBOARD3_PERIOD_BUTTON_X_MIN, KEYBOARD3_PERIOD_BUTTON_X_MAX, KEYBOARD3_PERIOD_BUTTON_Y_MIN, KEYBOARD3_PERIOD_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_COMMA_BUTTON_X_MIN, KEYBOARD3_COMMA_BUTTON_X_MAX, KEYBOARD3_COMMA_BUTTON_Y_MIN, KEYBOARD3_COMMA_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_QUESTION_MARK_BUTTON_X_MIN, KEYBOARD3_QUESTION_MARK_BUTTON_X_MAX, KEYBOARD3_QUESTION_MARK_BUTTON_Y_MIN, KEYBOARD3_QUESTION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_EXCLAMATION_MARK_BUTTON_X_MIN, KEYBOARD3_EXCLAMATION_MARK_BUTTON_X_MAX, KEYBOARD3_EXCLAMATION_MARK_BUTTON_Y_MIN, KEYBOARD3_EXCLAMATION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_SINGLE_QUOTE_BUTTON_X_MIN, KEYBOARD3_SINGLE_QUOTE_BUTTON_X_MAX, KEYBOARD3_SINGLE_QUOTE_BUTTON_Y_MIN, KEYBOARD3_SINGLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_BACKSPACE_BUTTON_X_MIN, KEYBOARD3_BACKSPACE_BUTTON_X_MAX, KEYBOARD3_BACKSPACE_BUTTON_Y_MIN, KEYBOARD3_BACKSPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MIN, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MAX, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MIN,         // row 4 of 4
      KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_SPACE_BUTTON_X_MIN, KEYBOARD3_SPACE_BUTTON_X_MAX, KEYBOARD3_SPACE_BUTTON_Y_MIN, KEYBOARD3_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_RETURN_BUTTON_X_MIN, KEYBOARD3_RETURN_BUTTON_X_MAX, KEYBOARD3_RETURN_BUTTON_Y_MIN, KEYBOARD3_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR}
};

// keyboard #3 (click)
const static Rectangle section_keyboard3_click[] =
{
     {NUM_1_BUTTON_X_MIN, NUM_1_BUTTON_X_MAX, NUM_1_BUTTON_Y_MIN, NUM_1_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                            // row 1 of 4
     {NUM_2_BUTTON_X_MIN, NUM_2_BUTTON_X_MAX, NUM_2_BUTTON_Y_MIN, NUM_2_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_3_BUTTON_X_MIN, NUM_3_BUTTON_X_MAX, NUM_3_BUTTON_Y_MIN, NUM_3_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_4_BUTTON_X_MIN, NUM_4_BUTTON_X_MAX, NUM_4_BUTTON_Y_MIN, NUM_4_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_5_BUTTON_X_MIN, NUM_5_BUTTON_X_MAX, NUM_5_BUTTON_Y_MIN, NUM_5_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_6_BUTTON_X_MIN, NUM_6_BUTTON_X_MAX, NUM_6_BUTTON_Y_MIN, NUM_6_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_7_BUTTON_X_MIN, NUM_7_BUTTON_X_MAX, NUM_7_BUTTON_Y_MIN, NUM_7_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_8_BUTTON_X_MIN, NUM_8_BUTTON_X_MAX, NUM_8_BUTTON_Y_MIN, NUM_8_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_9_BUTTON_X_MIN, NUM_9_BUTTON_X_MAX, NUM_9_BUTTON_Y_MIN, NUM_9_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {NUM_0_BUTTON_X_MIN, NUM_0_BUTTON_X_MAX, NUM_0_BUTTON_Y_MIN, NUM_0_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {DASH_BUTTON_X_MIN, DASH_BUTTON_X_MAX, DASH_BUTTON_Y_MIN, DASH_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                // row 2 of 4
     {FORWARD_SLASH_BUTTON_X_MIN, FORWARD_SLASH_BUTTON_X_MAX, FORWARD_SLASH_BUTTON_Y_MIN, FORWARD_SLASH_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {COLON_BUTTON_X_MIN, COLON_BUTTON_X_MAX, COLON_BUTTON_Y_MIN, COLON_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {SEMICOLON_BUTTON_X_MIN, SEMICOLON_BUTTON_X_MAX, SEMICOLON_BUTTON_Y_MIN, SEMICOLON_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {OPENING_PAREN_BUTTON_X_MIN, OPENING_PAREN_BUTTON_X_MAX, OPENING_PAREN_BUTTON_Y_MIN, OPENING_PAREN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {CLOSING_PAREN_BUTTON_X_MIN, CLOSING_PAREN_BUTTON_X_MAX, CLOSING_PAREN_BUTTON_Y_MIN, CLOSING_PAREN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {DOLLAR_SIGN_BUTTON_X_MIN, DOLLAR_SIGN_BUTTON_X_MAX, DOLLAR_SIGN_BUTTON_Y_MIN, DOLLAR_SIGN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {AMPERSAND_BUTTON_X_MIN, AMPERSAND_BUTTON_X_MAX, AMPERSAND_BUTTON_Y_MIN, AMPERSAND_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {AT_BUTTON_X_MIN, AT_BUTTON_X_MAX, AT_BUTTON_Y_MIN, AT_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {DOUBLE_QUOTE_BUTTON_X_MIN, DOUBLE_QUOTE_BUTTON_X_MAX, DOUBLE_QUOTE_BUTTON_Y_MIN, DOUBLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {SYMBOLS_BUTTON_X_MIN, SYMBOLS_BUTTON_X_MAX, SYMBOLS_BUTTON_Y_MIN, SYMBOLS_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                    // row 3 of 4
     {KEYBOARD3_PERIOD_BUTTON_X_MIN, KEYBOARD3_PERIOD_BUTTON_X_MAX, KEYBOARD3_PERIOD_BUTTON_Y_MIN, KEYBOARD3_PERIOD_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_COMMA_BUTTON_X_MIN, KEYBOARD3_COMMA_BUTTON_X_MAX, KEYBOARD3_COMMA_BUTTON_Y_MIN, KEYBOARD3_COMMA_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_QUESTION_MARK_BUTTON_X_MIN, KEYBOARD3_QUESTION_MARK_BUTTON_X_MAX, KEYBOARD3_QUESTION_MARK_BUTTON_Y_MIN, KEYBOARD3_QUESTION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_EXCLAMATION_MARK_BUTTON_X_MIN, KEYBOARD3_EXCLAMATION_MARK_BUTTON_X_MAX, KEYBOARD3_EXCLAMATION_MARK_BUTTON_Y_MIN, KEYBOARD3_EXCLAMATION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_SINGLE_QUOTE_BUTTON_X_MIN, KEYBOARD3_SINGLE_QUOTE_BUTTON_X_MAX, KEYBOARD3_SINGLE_QUOTE_BUTTON_Y_MIN, KEYBOARD3_SINGLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_BACKSPACE_BUTTON_X_MIN, KEYBOARD3_BACKSPACE_BUTTON_X_MAX, KEYBOARD3_BACKSPACE_BUTTON_Y_MIN, KEYBOARD3_BACKSPACE_BUTTON_Y_MAX, COMPOSE_MESSAGE_BACKSPACE_BUTTON_CLICK_COLOR},
     {KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MIN, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MAX, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MIN,         // row 4 of 4
      KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_SPACE_BUTTON_X_MIN, KEYBOARD3_SPACE_BUTTON_X_MAX, KEYBOARD3_SPACE_BUTTON_Y_MIN, KEYBOARD3_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
     {KEYBOARD3_RETURN_BUTTON_X_MIN, KEYBOARD3_RETURN_BUTTON_X_MAX, KEYBOARD3_RETURN_BUTTON_Y_MIN, KEYBOARD3_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR}
};

// keyboard #3 (no click) text
const static Text text_section_keyboard3_no_click[] =
{
     {NUM_1_BUTTON_TEXT_X_START, NUM_1_BUTTON_TEXT_Y_START, "1", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                                           // row 1 of 4
     {NUM_2_BUTTON_TEXT_X_START, NUM_2_BUTTON_TEXT_Y_START, "2", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_3_BUTTON_TEXT_X_START, NUM_3_BUTTON_TEXT_Y_START, "3", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_4_BUTTON_TEXT_X_START, NUM_4_BUTTON_TEXT_Y_START, "4", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_5_BUTTON_TEXT_X_START, NUM_5_BUTTON_TEXT_Y_START, "5", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_6_BUTTON_TEXT_X_START, NUM_6_BUTTON_TEXT_Y_START, "6", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_7_BUTTON_TEXT_X_START, NUM_7_BUTTON_TEXT_Y_START, "7", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_8_BUTTON_TEXT_X_START, NUM_8_BUTTON_TEXT_Y_START, "8", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_9_BUTTON_TEXT_X_START, NUM_9_BUTTON_TEXT_Y_START, "9", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {NUM_0_BUTTON_TEXT_X_START, NUM_0_BUTTON_TEXT_Y_START, "0", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {DASH_BUTTON_TEXT_X_START, DASH_BUTTON_TEXT_Y_START, "-", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                                             // row 2 of 4
     {FORWARD_SLASH_BUTTON_TEXT_X_START, FORWARD_SLASH_BUTTON_TEXT_Y_START, "/", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {COLON_BUTTON_TEXT_X_START, COLON_BUTTON_TEXT_Y_START, ":", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {SEMICOLON_BUTTON_TEXT_X_START, SEMICOLON_BUTTON_TEXT_Y_START, ";", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {OPENING_PAREN_BUTTON_TEXT_X_START, OPENING_PAREN_BUTTON_TEXT_Y_START, "(", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {CLOSING_PAREN_BUTTON_TEXT_X_START, CLOSING_PAREN_BUTTON_TEXT_Y_START, ")", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {DOLLAR_SIGN_BUTTON_TEXT_X_START, DOLLAR_SIGN_BUTTON_TEXT_Y_START, "$", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {AMPERSAND_BUTTON_TEXT_X_START, AMPERSAND_BUTTON_TEXT_Y_START, "&", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {AT_BUTTON_TEXT_X_START, AT_BUTTON_TEXT_Y_START, "@", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {DOUBLE_QUOTE_BUTTON_TEXT_X_START, DOUBLE_QUOTE_BUTTON_TEXT_Y_START, "\"", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {SYMBOLS_BUTTON_TEXT_X_START, SYMBOLS_BUTTON_TEXT_Y_START, "#+=", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                                    // row 3 of 4
     {KEYBOARD3_PERIOD_BUTTON_TEXT_X_START, KEYBOARD3_PERIOD_BUTTON_TEXT_Y_START, ".", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_COMMA_BUTTON_TEXT_X_START, KEYBOARD3_COMMA_BUTTON_TEXT_Y_START, ",", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_QUESTION_MARK_BUTTON_TEXT_X_START, KEYBOARD3_QUESTION_MARK_BUTTON_TEXT_Y_START, "?", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_EXCLAMATION_MARK_BUTTON_TEXT_X_START, KEYBOARD3_EXCLAMATION_MARK_BUTTON_TEXT_Y_START, "!", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_SINGLE_QUOTE_BUTTON_TEXT_X_START, KEYBOARD3_SINGLE_QUOTE_BUTTON_TEXT_Y_START, "'", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD3_BACKSPACE_BUTTON_TEXT_Y_START, "<X", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_X_START, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_Y_START, "ABC", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                    // row 4 of 4
     {KEYBOARD3_SPACE_BUTTON_TEXT_X_START, KEYBOARD3_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
     {KEYBOARD3_RETURN_BUTTON_TEXT_X_START, KEYBOARD3_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR}
};


// keyboard #3 (click) text
const static Text text_section_keyboard3_click[] =
{
     {NUM_1_BUTTON_TEXT_X_START, NUM_1_BUTTON_TEXT_Y_START, "1", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                                      // row 1 of 4
     {NUM_2_BUTTON_TEXT_X_START, NUM_2_BUTTON_TEXT_Y_START, "2", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_3_BUTTON_TEXT_X_START, NUM_3_BUTTON_TEXT_Y_START, "3", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_4_BUTTON_TEXT_X_START, NUM_4_BUTTON_TEXT_Y_START, "4", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_5_BUTTON_TEXT_X_START, NUM_5_BUTTON_TEXT_Y_START, "5", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_6_BUTTON_TEXT_X_START, NUM_6_BUTTON_TEXT_Y_START, "6", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_7_BUTTON_TEXT_X_START, NUM_7_BUTTON_TEXT_Y_START, "7", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_8_BUTTON_TEXT_X_START, NUM_8_BUTTON_TEXT_Y_START, "8", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_9_BUTTON_TEXT_X_START, NUM_9_BUTTON_TEXT_Y_START, "9", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {NUM_0_BUTTON_TEXT_X_START, NUM_0_BUTTON_TEXT_Y_START, "0", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {DASH_BUTTON_TEXT_X_START, DASH_BUTTON_TEXT_Y_START, "-", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                                        // row 2 of 4
     {FORWARD_SLASH_BUTTON_TEXT_X_START, FORWARD_SLASH_BUTTON_TEXT_Y_START, "/", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {COLON_BUTTON_TEXT_X_START, COLON_BUTTON_TEXT_Y_START, ":", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {SEMICOLON_BUTTON_TEXT_X_START, SEMICOLON_BUTTON_TEXT_Y_START, ";", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {OPENING_PAREN_BUTTON_TEXT_X_START, OPENING_PAREN_BUTTON_TEXT_Y_START, "(", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {CLOSING_PAREN_BUTTON_TEXT_X_START, CLOSING_PAREN_BUTTON_TEXT_Y_START, ")", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {DOLLAR_SIGN_BUTTON_TEXT_X_START, DOLLAR_SIGN_BUTTON_TEXT_Y_START, "$", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {AMPERSAND_BUTTON_TEXT_X_START, AMPERSAND_BUTTON_TEXT_Y_START, "&", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {AT_BUTTON_TEXT_X_START, AT_BUTTON_TEXT_Y_START, "@", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {DOUBLE_QUOTE_BUTTON_TEXT_X_START, DOUBLE_QUOTE_BUTTON_TEXT_Y_START, "\"", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {SYMBOLS_BUTTON_TEXT_X_START, SYMBOLS_BUTTON_TEXT_Y_START, "#+=", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                                // row 3 of 4
     {KEYBOARD3_PERIOD_BUTTON_TEXT_X_START, KEYBOARD3_PERIOD_BUTTON_TEXT_Y_START, ".", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_COMMA_BUTTON_TEXT_X_START, KEYBOARD3_COMMA_BUTTON_TEXT_Y_START, ",", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_QUESTION_MARK_BUTTON_TEXT_X_START, KEYBOARD3_QUESTION_MARK_BUTTON_TEXT_Y_START, "?", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_EXCLAMATION_MARK_BUTTON_TEXT_X_START, KEYBOARD3_EXCLAMATION_MARK_BUTTON_TEXT_Y_START, "!", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_SINGLE_QUOTE_BUTTON_TEXT_X_START, KEYBOARD3_SINGLE_QUOTE_BUTTON_TEXT_Y_START, "'", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD3_BACKSPACE_BUTTON_TEXT_Y_START, "<X", COMPOSE_MESSAGE_BACKSPACE_BUTTON_TEXT_CLICK_COLOR},
     {KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_X_START, KEYBOARD3_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_Y_START, "ABC", KEYBOARD_KEY_TEXT_CLICK_COLOR},                    // row 4 of 4
     {KEYBOARD3_SPACE_BUTTON_TEXT_X_START, KEYBOARD3_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_CLICK_COLOR},
     {KEYBOARD3_RETURN_BUTTON_TEXT_X_START, KEYBOARD3_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_CLICK_COLOR}
};


// keyboard #4 (no click)
const static Rectangle section_keyboard4_no_click[] =
{
     {OPENING_BRACKET_SYMBOL_BUTTON_X_MIN, OPENING_BRACKET_SYMBOL_BUTTON_X_MAX, OPENING_BRACKET_SYMBOL_BUTTON_Y_MIN, OPENING_BRACKET_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                               // row 1 of 4
     {CLOSING_BRACKET_SYMBOL_BUTTON_X_MIN, CLOSING_BRACKET_SYMBOL_BUTTON_X_MAX, CLOSING_BRACKET_SYMBOL_BUTTON_Y_MIN, CLOSING_BRACKET_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {OPENING_BRACE_SYMBOL_BUTTON_X_MIN, OPENING_BRACE_SYMBOL_BUTTON_X_MAX, OPENING_BRACE_SYMBOL_BUTTON_Y_MIN, OPENING_BRACE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {CLOSING_BRACE_SYMBOL_BUTTON_X_MIN, CLOSING_BRACE_SYMBOL_BUTTON_X_MAX, CLOSING_BRACE_SYMBOL_BUTTON_Y_MIN, CLOSING_BRACE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUMBER_SYMBOL_BUTTON_X_MIN, NUMBER_SYMBOL_BUTTON_X_MAX, NUMBER_SYMBOL_BUTTON_Y_MIN, NUMBER_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {PERCENTAGE_SYMBOL_BUTTON_X_MIN, PERCENTAGE_SYMBOL_BUTTON_X_MAX, PERCENTAGE_SYMBOL_BUTTON_Y_MIN, PERCENTAGE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {CARAT_SYMBOL_BUTTON_X_MIN, CARAT_SYMBOL_BUTTON_X_MAX, CARAT_SYMBOL_BUTTON_Y_MIN, CARAT_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {ASTERISK_SYMBOL_BUTTON_X_MIN, ASTERISK_SYMBOL_BUTTON_X_MAX, ASTERISK_SYMBOL_BUTTON_Y_MIN, ASTERISK_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {PLUS_SYMBOL_BUTTON_X_MIN, PLUS_SYMBOL_BUTTON_X_MAX, PLUS_SYMBOL_BUTTON_Y_MIN, PLUS_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {EQUALS_SYMBOL_BUTTON_X_MIN, EQUALS_SYMBOL_BUTTON_X_MAX, EQUALS_SYMBOL_BUTTON_Y_MIN, EQUALS_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {UNDERSCORE_SYMBOL_BUTTON_X_MIN, UNDERSCORE_SYMBOL_BUTTON_X_MAX, UNDERSCORE_SYMBOL_BUTTON_Y_MIN, UNDERSCORE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                                   // row 2 of 4
     {PIPE_SYMBOL_BUTTON_X_MIN, PIPE_SYMBOL_BUTTON_X_MAX, PIPE_SYMBOL_BUTTON_Y_MIN, PIPE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {LESS_THAN_SYMBOL_BUTTON_X_MIN, LESS_THAN_SYMBOL_BUTTON_X_MAX, LESS_THAN_SYMBOL_BUTTON_Y_MIN, LESS_THAN_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {GREATER_THAN_SYMBOL_BUTTON_X_MIN, GREATER_THAN_SYMBOL_BUTTON_X_MAX, GREATER_THAN_SYMBOL_BUTTON_Y_MIN, GREATER_THAN_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {SMILEY_FACE_BUTTON_X_MIN, SMILEY_FACE_BUTTON_X_MAX, SMILEY_FACE_BUTTON_Y_MIN, SMILEY_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {SAD_FACE_BUTTON_X_MIN, SAD_FACE_BUTTON_X_MAX, SAD_FACE_BUTTON_Y_MIN, SAD_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {WINKY_FACE_BUTTON_X_MIN, WINKY_FACE_BUTTON_X_MAX, WINKY_FACE_BUTTON_Y_MIN, WINKY_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {MERP_FACE_BUTTON_X_MIN, MERP_FACE_BUTTON_X_MAX, MERP_FACE_BUTTON_Y_MIN, MERP_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {RAWR_FACE_BUTTON_X_MIN, RAWR_FACE_BUTTON_X_MAX, RAWR_FACE_BUTTON_Y_MIN, RAWR_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {TONGUE_OUT_FACE_BUTTON_X_MIN, TONGUE_OUT_FACE_BUTTON_X_MAX, TONGUE_OUT_FACE_BUTTON_Y_MIN, TONGUE_OUT_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {NUMBERS_BUTTON_X_MIN, NUMBERS_BUTTON_X_MAX, NUMBERS_BUTTON_Y_MIN, NUMBERS_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},                       // row 3 of 4
     {KEYBOARD4_PERIOD_BUTTON_X_MIN, KEYBOARD4_PERIOD_BUTTON_X_MAX, KEYBOARD4_PERIOD_BUTTON_Y_MIN, KEYBOARD4_PERIOD_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_COMMA_BUTTON_X_MIN, KEYBOARD4_COMMA_BUTTON_X_MAX, KEYBOARD4_COMMA_BUTTON_Y_MIN, KEYBOARD4_COMMA_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_QUESTION_MARK_BUTTON_X_MIN, KEYBOARD4_QUESTION_MARK_BUTTON_X_MAX, KEYBOARD4_QUESTION_MARK_BUTTON_Y_MIN, KEYBOARD4_QUESTION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_EXCLAMATION_MARK_BUTTON_X_MIN, KEYBOARD4_EXCLAMATION_MARK_BUTTON_X_MAX, KEYBOARD4_EXCLAMATION_MARK_BUTTON_Y_MIN, KEYBOARD4_EXCLAMATION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_SINGLE_QUOTE_BUTTON_X_MIN, KEYBOARD4_SINGLE_QUOTE_BUTTON_X_MAX, KEYBOARD4_SINGLE_QUOTE_BUTTON_Y_MIN, KEYBOARD4_SINGLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD3_BACKSPACE_BUTTON_X_MIN, KEYBOARD3_BACKSPACE_BUTTON_X_MAX, KEYBOARD3_BACKSPACE_BUTTON_Y_MIN, KEYBOARD3_BACKSPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MIN, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MAX, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MIN,         // row 4 of 4
      KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_SPACE_BUTTON_X_MIN, KEYBOARD4_SPACE_BUTTON_X_MAX, KEYBOARD4_SPACE_BUTTON_Y_MIN, KEYBOARD4_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR},
     {KEYBOARD4_RETURN_BUTTON_X_MIN, KEYBOARD4_RETURN_BUTTON_X_MAX, KEYBOARD4_RETURN_BUTTON_Y_MIN, KEYBOARD4_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_NO_CLICK_COLOR}
};

// keyboard #4 (click)
const static Rectangle section_keyboard4_click[] =
{
    {OPENING_BRACKET_SYMBOL_BUTTON_X_MIN, OPENING_BRACKET_SYMBOL_BUTTON_X_MAX, OPENING_BRACKET_SYMBOL_BUTTON_Y_MIN, OPENING_BRACKET_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                               // row 1 of 4
    {CLOSING_BRACKET_SYMBOL_BUTTON_X_MIN, CLOSING_BRACKET_SYMBOL_BUTTON_X_MAX, CLOSING_BRACKET_SYMBOL_BUTTON_Y_MIN, CLOSING_BRACKET_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {OPENING_BRACE_SYMBOL_BUTTON_X_MIN, OPENING_BRACE_SYMBOL_BUTTON_X_MAX, OPENING_BRACE_SYMBOL_BUTTON_Y_MIN, OPENING_BRACE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {CLOSING_BRACE_SYMBOL_BUTTON_X_MIN, CLOSING_BRACE_SYMBOL_BUTTON_X_MAX, CLOSING_BRACE_SYMBOL_BUTTON_Y_MIN, CLOSING_BRACE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {NUMBER_SYMBOL_BUTTON_X_MIN, NUMBER_SYMBOL_BUTTON_X_MAX, NUMBER_SYMBOL_BUTTON_Y_MIN, NUMBER_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {PERCENTAGE_SYMBOL_BUTTON_X_MIN, PERCENTAGE_SYMBOL_BUTTON_X_MAX, PERCENTAGE_SYMBOL_BUTTON_Y_MIN, PERCENTAGE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {CARAT_SYMBOL_BUTTON_X_MIN, CARAT_SYMBOL_BUTTON_X_MAX, CARAT_SYMBOL_BUTTON_Y_MIN, CARAT_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {ASTERISK_SYMBOL_BUTTON_X_MIN, ASTERISK_SYMBOL_BUTTON_X_MAX, ASTERISK_SYMBOL_BUTTON_Y_MIN, ASTERISK_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {PLUS_SYMBOL_BUTTON_X_MIN, PLUS_SYMBOL_BUTTON_X_MAX, PLUS_SYMBOL_BUTTON_Y_MIN, PLUS_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {EQUALS_SYMBOL_BUTTON_X_MIN, EQUALS_SYMBOL_BUTTON_X_MAX, EQUALS_SYMBOL_BUTTON_Y_MIN, EQUALS_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {UNDERSCORE_SYMBOL_BUTTON_X_MIN, UNDERSCORE_SYMBOL_BUTTON_X_MAX, UNDERSCORE_SYMBOL_BUTTON_Y_MIN, UNDERSCORE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                                   // row 2 of 4
    {PIPE_SYMBOL_BUTTON_X_MIN, PIPE_SYMBOL_BUTTON_X_MAX, PIPE_SYMBOL_BUTTON_Y_MIN, PIPE_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {LESS_THAN_SYMBOL_BUTTON_X_MIN, LESS_THAN_SYMBOL_BUTTON_X_MAX, LESS_THAN_SYMBOL_BUTTON_Y_MIN, LESS_THAN_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {GREATER_THAN_SYMBOL_BUTTON_X_MIN, GREATER_THAN_SYMBOL_BUTTON_X_MAX, GREATER_THAN_SYMBOL_BUTTON_Y_MIN, GREATER_THAN_SYMBOL_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {SMILEY_FACE_BUTTON_X_MIN, SMILEY_FACE_BUTTON_X_MAX, SMILEY_FACE_BUTTON_Y_MIN, SMILEY_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {SAD_FACE_BUTTON_X_MIN, SAD_FACE_BUTTON_X_MAX, SAD_FACE_BUTTON_Y_MIN, SAD_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {WINKY_FACE_BUTTON_X_MIN, WINKY_FACE_BUTTON_X_MAX, WINKY_FACE_BUTTON_Y_MIN, WINKY_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {MERP_FACE_BUTTON_X_MIN, MERP_FACE_BUTTON_X_MAX, MERP_FACE_BUTTON_Y_MIN, MERP_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {RAWR_FACE_BUTTON_X_MIN, RAWR_FACE_BUTTON_X_MAX, RAWR_FACE_BUTTON_Y_MIN, RAWR_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {TONGUE_OUT_FACE_BUTTON_X_MIN, TONGUE_OUT_FACE_BUTTON_X_MAX, TONGUE_OUT_FACE_BUTTON_Y_MIN, TONGUE_OUT_FACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {NUMBERS_BUTTON_X_MIN, NUMBERS_BUTTON_X_MAX, NUMBERS_BUTTON_Y_MIN, NUMBERS_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},                       // row 3 of 4
    {KEYBOARD4_PERIOD_BUTTON_X_MIN, KEYBOARD4_PERIOD_BUTTON_X_MAX, KEYBOARD4_PERIOD_BUTTON_Y_MIN, KEYBOARD4_PERIOD_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_COMMA_BUTTON_X_MIN, KEYBOARD4_COMMA_BUTTON_X_MAX, KEYBOARD4_COMMA_BUTTON_Y_MIN, KEYBOARD4_COMMA_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_QUESTION_MARK_BUTTON_X_MIN, KEYBOARD4_QUESTION_MARK_BUTTON_X_MAX, KEYBOARD4_QUESTION_MARK_BUTTON_Y_MIN, KEYBOARD4_QUESTION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_EXCLAMATION_MARK_BUTTON_X_MIN, KEYBOARD4_EXCLAMATION_MARK_BUTTON_X_MAX, KEYBOARD4_EXCLAMATION_MARK_BUTTON_Y_MIN, KEYBOARD4_EXCLAMATION_MARK_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_SINGLE_QUOTE_BUTTON_X_MIN, KEYBOARD4_SINGLE_QUOTE_BUTTON_X_MAX, KEYBOARD4_SINGLE_QUOTE_BUTTON_Y_MIN, KEYBOARD4_SINGLE_QUOTE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD3_BACKSPACE_BUTTON_X_MIN, KEYBOARD3_BACKSPACE_BUTTON_X_MAX, KEYBOARD3_BACKSPACE_BUTTON_Y_MIN, KEYBOARD3_BACKSPACE_BUTTON_Y_MAX, COMPOSE_MESSAGE_BACKSPACE_BUTTON_CLICK_COLOR},
    {KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MIN, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_X_MAX, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MIN,         // row 4 of 4
     KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_SPACE_BUTTON_X_MIN, KEYBOARD4_SPACE_BUTTON_X_MAX, KEYBOARD4_SPACE_BUTTON_Y_MIN, KEYBOARD4_SPACE_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR},
    {KEYBOARD4_RETURN_BUTTON_X_MIN, KEYBOARD4_RETURN_BUTTON_X_MAX, KEYBOARD4_RETURN_BUTTON_Y_MIN, KEYBOARD4_RETURN_BUTTON_Y_MAX, KEYBOARD_KEY_CLICK_COLOR}
};

// keyboard #4 (no click) text
const static Text text_section_keyboard4_no_click[] =
{
    {OPENING_BRACKET_SYMBOL_BUTTON_TEXT_X_START, OPENING_BRACKET_SYMBOL_BUTTON_TEXT_Y_START, "[", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                               // row 1 of 4
    {CLOSING_BRACKET_SYMBOL_BUTTON_TEXT_X_START, CLOSING_BRACKET_SYMBOL_BUTTON_TEXT_Y_START, "]", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {OPENING_BRACE_SYMBOL_BUTTON_TEXT_X_START, OPENING_BRACE_SYMBOL_BUTTON_TEXT_Y_START, "{", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {CLOSING_BRACE_SYMBOL_BUTTON_TEXT_X_START, CLOSING_BRACE_SYMBOL_BUTTON_TEXT_Y_START, "}", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {NUMBER_SYMBOL_BUTTON_TEXT_X_START, NUMBER_SYMBOL_BUTTON_TEXT_Y_START, "#", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {PERCENTAGE_SYMBOL_BUTTON_TEXT_X_START, PERCENTAGE_SYMBOL_BUTTON_TEXT_Y_START, "%", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {CARAT_SYMBOL_BUTTON_TEXT_X_START, CARAT_SYMBOL_BUTTON_TEXT_Y_START, "^", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {ASTERISK_SYMBOL_BUTTON_TEXT_X_START, ASTERISK_SYMBOL_BUTTON_TEXT_Y_START, "*", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {PLUS_SYMBOL_BUTTON_TEXT_X_START, PLUS_SYMBOL_BUTTON_TEXT_Y_START, "+", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {EQUALS_SYMBOL_BUTTON_TEXT_X_START, EQUALS_SYMBOL_BUTTON_TEXT_Y_START, "=", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {UNDERSCORE_SYMBOL_BUTTON_TEXT_X_START, UNDERSCORE_SYMBOL_BUTTON_TEXT_Y_START, "_", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                                   // row 2 of 4
    {PIPE_SYMBOL_BUTTON_TEXT_X_START, PIPE_SYMBOL_BUTTON_TEXT_Y_START, "|", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {LESS_THAN_SYMBOL_BUTTON_TEXT_X_START, LESS_THAN_SYMBOL_BUTTON_TEXT_Y_START, "<", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {GREATER_THAN_SYMBOL_BUTTON_TEXT_X_START, GREATER_THAN_SYMBOL_BUTTON_TEXT_Y_START, ">", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {SMILEY_FACE_BUTTON_TEXT_X_START, SMILEY_FACE_BUTTON_TEXT_Y_START, ":)", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {SAD_FACE_BUTTON_TEXT_X_START, SAD_FACE_BUTTON_TEXT_Y_START, ":(", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {WINKY_FACE_BUTTON_TEXT_X_START, WINKY_FACE_BUTTON_TEXT_Y_START, ";)", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {MERP_FACE_BUTTON_TEXT_X_START, MERP_FACE_BUTTON_TEXT_Y_START, ":/", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {RAWR_FACE_BUTTON_TEXT_X_START, RAWR_FACE_BUTTON_TEXT_Y_START, "xD", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {TONGUE_OUT_FACE_BUTTON_TEXT_X_START, TONGUE_OUT_FACE_BUTTON_TEXT_Y_START, ":P", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {NUMBERS_BUTTON_TEXT_X_START, NUMBERS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                       // row 3 of 4
    {KEYBOARD4_PERIOD_BUTTON_TEXT_X_START, KEYBOARD4_PERIOD_BUTTON_TEXT_Y_START, ".", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_COMMA_BUTTON_TEXT_X_START, KEYBOARD4_COMMA_BUTTON_TEXT_Y_START, ",", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_QUESTION_MARK_BUTTON_TEXT_X_START, KEYBOARD4_QUESTION_MARK_BUTTON_TEXT_Y_START, "?", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_EXCLAMATION_MARK_BUTTON_TEXT_X_START, KEYBOARD4_EXCLAMATION_MARK_BUTTON_TEXT_Y_START, "!", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_SINGLE_QUOTE_BUTTON_TEXT_X_START, KEYBOARD4_SINGLE_QUOTE_BUTTON_TEXT_Y_START, "'", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD4_BACKSPACE_BUTTON_TEXT_Y_START, "<X", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_X_START, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_Y_START, "ABC", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},                    // row 4 of 4
    {KEYBOARD4_SPACE_BUTTON_TEXT_X_START, KEYBOARD4_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR},
    {KEYBOARD4_RETURN_BUTTON_TEXT_X_START, KEYBOARD4_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_NO_CLICK_COLOR}
};


// keyboard #4 (click) text
const static Text text_section_keyboard4_click[] =
{
    {OPENING_BRACKET_SYMBOL_BUTTON_TEXT_X_START, OPENING_BRACKET_SYMBOL_BUTTON_TEXT_Y_START, "[", KEYBOARD_KEY_TEXT_CLICK_COLOR},                               // row 1 of 4
    {CLOSING_BRACKET_SYMBOL_BUTTON_TEXT_X_START, CLOSING_BRACKET_SYMBOL_BUTTON_TEXT_Y_START, "]", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {OPENING_BRACE_SYMBOL_BUTTON_TEXT_X_START, OPENING_BRACE_SYMBOL_BUTTON_TEXT_Y_START, "{", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {CLOSING_BRACE_SYMBOL_BUTTON_TEXT_X_START, CLOSING_BRACE_SYMBOL_BUTTON_TEXT_Y_START, "}", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {NUMBER_SYMBOL_BUTTON_TEXT_X_START, NUMBER_SYMBOL_BUTTON_TEXT_Y_START, "#", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {PERCENTAGE_SYMBOL_BUTTON_TEXT_X_START, PERCENTAGE_SYMBOL_BUTTON_TEXT_Y_START, "%", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {CARAT_SYMBOL_BUTTON_TEXT_X_START, CARAT_SYMBOL_BUTTON_TEXT_Y_START, "^", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {ASTERISK_SYMBOL_BUTTON_TEXT_X_START, ASTERISK_SYMBOL_BUTTON_TEXT_Y_START, "*", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {PLUS_SYMBOL_BUTTON_TEXT_X_START, PLUS_SYMBOL_BUTTON_TEXT_Y_START, "+", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {EQUALS_SYMBOL_BUTTON_TEXT_X_START, EQUALS_SYMBOL_BUTTON_TEXT_Y_START, "=", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {UNDERSCORE_SYMBOL_BUTTON_TEXT_X_START, UNDERSCORE_SYMBOL_BUTTON_TEXT_Y_START, "_", KEYBOARD_KEY_TEXT_CLICK_COLOR},                                   // row 2 of 4
    {PIPE_SYMBOL_BUTTON_TEXT_X_START, PIPE_SYMBOL_BUTTON_TEXT_Y_START, "|", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {LESS_THAN_SYMBOL_BUTTON_TEXT_X_START, LESS_THAN_SYMBOL_BUTTON_TEXT_Y_START, "<", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {GREATER_THAN_SYMBOL_BUTTON_TEXT_X_START, GREATER_THAN_SYMBOL_BUTTON_TEXT_Y_START, ">", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {SMILEY_FACE_BUTTON_TEXT_X_START, SMILEY_FACE_BUTTON_TEXT_Y_START, ":)", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {SAD_FACE_BUTTON_TEXT_X_START, SAD_FACE_BUTTON_TEXT_Y_START, ":(", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {WINKY_FACE_BUTTON_TEXT_X_START, WINKY_FACE_BUTTON_TEXT_Y_START, ";)", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {MERP_FACE_BUTTON_TEXT_X_START, MERP_FACE_BUTTON_TEXT_Y_START, ":/", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {RAWR_FACE_BUTTON_TEXT_X_START, RAWR_FACE_BUTTON_TEXT_Y_START, "xD", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {TONGUE_OUT_FACE_BUTTON_TEXT_X_START, TONGUE_OUT_FACE_BUTTON_TEXT_Y_START, ":P", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {NUMBERS_BUTTON_TEXT_X_START, NUMBERS_BUTTON_TEXT_Y_START, "123", KEYBOARD_KEY_TEXT_CLICK_COLOR},                       // row 3 of 4
    {KEYBOARD4_PERIOD_BUTTON_TEXT_X_START, KEYBOARD4_PERIOD_BUTTON_TEXT_Y_START, ".", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_COMMA_BUTTON_TEXT_X_START, KEYBOARD4_COMMA_BUTTON_TEXT_Y_START, ",", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_QUESTION_MARK_BUTTON_TEXT_X_START, KEYBOARD4_QUESTION_MARK_BUTTON_TEXT_Y_START, "?", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_EXCLAMATION_MARK_BUTTON_TEXT_X_START, KEYBOARD4_EXCLAMATION_MARK_BUTTON_TEXT_Y_START, "!", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_SINGLE_QUOTE_BUTTON_TEXT_X_START, KEYBOARD4_SINGLE_QUOTE_BUTTON_TEXT_Y_START, "'", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_BACKSPACE_BUTTON_TEXT_X_START, KEYBOARD4_BACKSPACE_BUTTON_TEXT_Y_START, "<X", COMPOSE_MESSAGE_BACKSPACE_BUTTON_TEXT_CLICK_COLOR},
    {KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_X_START, KEYBOARD4_CHANGE_TO_ALPHABET_KEYBOARD_BUTTON_TEXT_Y_START, "ABC", KEYBOARD_KEY_TEXT_CLICK_COLOR},                    // row 4 of 4
    {KEYBOARD4_SPACE_BUTTON_TEXT_X_START, KEYBOARD4_SPACE_BUTTON_TEXT_Y_START, "SPACE", KEYBOARD_KEY_TEXT_CLICK_COLOR},
    {KEYBOARD4_RETURN_BUTTON_TEXT_X_START, KEYBOARD4_RETURN_BUTTON_TEXT_Y_START, "RETURN", KEYBOARD_KEY_TEXT_CLICK_COLOR}
};

/* miscellaneous compose message defines */

// first of three char arrays used to represent the first of three keyboards
// when checking for touches made to keyboard
// NOTE: '^' is a filler used to determine when to change keyboard to upper-case keyboard
// NOTE: '1' is a filler used to determine when to change keyboard to numbers/symbols keyboard
// NOTE: ' ' is a filler used to determine when to add a space to the messgge
// NOTE: '|' is a filler used to determine when to create a new line
const static char keyboard1_keys[31] =
{
 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
   'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l',
   '^', 'z', 'x', 'c', 'v', 'b', 'n', 'm', '<',
                  '1', ' ', '|'
};

// NOTE: '^' is a filler used to determine when to change keyboard to lower-case keyboard
// NOTE: '@' is a filler used to determine when to change keyboard to alphabet keyboard
// NOTE: ' ' is a filler used to determine when to add a space to the messgge
// NOTE: '|' is a filler used to determine when to create a new line
const static char keyboard2_keys[31] =
{
 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
   'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
   '^', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<',
                  '@', ' ', '|'
};

// NOTE: '^' is a filler used to determine when to change keyboard to more symbols keyboard (keyboard #4)
// NOTE: 'a' is a filler used to determine when to change keyboard to alphabet keyboard
// NOTE: ' ' is a filler used to determine when to add a space to the messgge
// NOTE: '|' is a filler used to determine when to create a new line
const static char keyboard3_keys[30] =
{
 '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
 '-', '/', ':', ';', '(', ')', '$', '&', '@', '\"',
      '^', '.', ',', '?', '!', '\'', '<',
                 'a', ' ', '|'
};

// NOTE: '^' is a filler used to determine when to change keyboard to lower-case keyboard
// NOTE: 'a' is a filler used to determine when to change keyboard to alphabet keyboard
// NOTE: ' ' is a filler used to determine when to add a space to the messgge
// NOTE: '|' is a filler used to determine when to create a new line
// NOTE: 'h' is a filler used to determine when to create a happy face ":)"
// NOTE: 's' is a filler used to determine when to create a sad face ":("
// NOTE: 'w' is a filler used to determine when to create a winky face ";)"
// NOTE: 'm' is a filler used to determine when to create a merp face ":/"
// NOTE: 'r' is a filler used to determine when to create a rawr face "xD"
// NOTE: 't' is a filler used to determine when to create a tongue-out face ":P"
const static char keyboard4_keys[30] =
{
 '[', ']', '{', '}', '#', '%', '^', '*', '+', '=',
 '_', '|', '<', '>', 'h', 's', 'w', 'm', 'r', 't',
      '^', '.', ',', '?', '!', '\'', '<',
                 'a', ' ', '|'
};




// static cursor to be used in any typing environment
static Point cursor;

// variable to determine which keyboard is currently being output
static uint8_t keyboard;     // 4 possible keyboards (0-3) (IMPLEMENT BITFIELDS)

// flag used to determine which alphabet keyboard was displayed upon
// switching to numbers/symbols keyboard
static uint8_t lowercase_uppercase;     // 2 possible choices (0 for lowercase, 1 for uppercase) (IMPLEMENT BITFIELDS)


// index used to keep track of current character index in currently composed message
static uint16_t current_message_index = 0;

// current message being composed
static Message_Data_t message_data;

static bool kill_compose_message = false;


/************************* END OF COMPOSE MESSAGE MEMBERS **************************/

/***************************** MESSAGE LOG MEMBERS *********************************/
// message log background section
const static Rectangle section_message_log_background[] =
{
    {MESSAGE_LOG_BACKGROUND_X_MIN, MESSAGE_LOG_BACKGROUND_X_MAX,
     MESSAGE_LOG_BACKGROUND_Y_MIN, MESSAGE_LOG_BACKGROUND_Y_MAX,
     MESSAGE_LOG_BACKGROUND_COLOR}
};

// message log header bar
const static Rectangle section_message_log_header[] =
{
    {MESSAGE_LOG_HEADER_X_MIN, MESSAGE_LOG_HEADER_X_MAX,
     MESSAGE_LOG_HEADER_Y_MIN, MESSAGE_LOG_HEADER_Y_MAX,
     MESSAGE_LOG_HEADER_COLOR},
    {MESSAGE_LOG_HEADER_DIVIDER_X_MIN, MESSAGE_LOG_HEADER_DIVIDER_X_MAX,
     MESSAGE_LOG_HEADER_DIVIDER_Y_MIN, MESSAGE_LOG_HEADER_DIVIDER_Y_MAX,
     MESSAGE_LOG_HEADER_DIVIDER_COLOR}
};

// message log header bar buttons (back)
const static Rectangle section_message_log_header_buttons[] =
{
     {MESSAGE_LOG_BACK_BUTTON_X_MIN, MESSAGE_LOG_BACK_BUTTON_X_MAX,
      MESSAGE_LOG_BACK_BUTTON_Y_MIN, MESSAGE_LOG_BACK_BUTTON_Y_MAX,
      MESSAGE_LOG_BACK_BUTTON_COLOR}
};

// message log header buttons text
const static Text text_section_message_log_header[] =
{
     {MESSAGE_LOG_BACK_BUTTON_TEXT_X_START, MESSAGE_LOG_BACK_BUTTON_TEXT_Y_START,
      "< BACK", MESSAGE_LOG_BACK_BUTTON_TEXT_COLOR}
};

// message log text arena section
const static Rectangle section_message_log_text_arena[] =
{
     {MESSAGE_LOG_TEXT_ARENA_X_MIN, MESSAGE_LOG_TEXT_ARENA_X_MAX,
      MESSAGE_LOG_TEXT_ARENA_Y_MIN, MESSAGE_LOG_TEXT_ARENA_Y_MAX,
      MESSAGE_LOG_TEXT_ARENA_COLOR}
};

/************************ END OF MESSAGE LOG MEMBERS *********************************/


// boolean to determine if application has previously been initialized
static bool applicationInitialized = false;

semaphore_t semaphore_cursor;

// private count of number of unread (new) messages
static uint16_t unread_message_count;

// message log
static Message_Log_t message_log[MAX_NUMBER_OF_CONTACTS];

//bool back_button_pressed = false;
uint16_t cursor_color;

bool message_received_in_log = false; //for updating the messaage log in real time

//////////////////////////END OF PRIVATE DATA MEMBERS////////////////////////////////

/////////////////////////////////PRIVATE FUNCTIONS///////////////////////////////////




/************************************************************************************
* Name: insert_character
* Purpose: Helper function to insert an ASCII character from a given cursor position
* Input(s): Point cursor, uint8_t character
* Output: N/A
************************************************************************************/
static inline void insert_character(uint8_t character)
{
    // IMPLEMENT: insert semaphore for cursor
    G8RTOS_semaphore_wait(&semaphore_cursor);
    //G8RTOS_semaphore_wait(&semaphore_LCD);

    if (cursor.x < COMPOSE_MESSAGE_CURSOR_X_MAX)
    {
        message_data.message[current_message_index++] = character;       // update current message

        message_data.header_info.size_of_data++;    // increment number of bytes to send

        // the only way to successfully write back a character after deleting a character
        // fucking beats Brit and I (QUESTION)


        LCD_DrawRectangle(cursor.x, (cursor.x + LCD_TEXT_WIDTH + CURSOR_OFFSET), TEXT_ARENA_Y_MIN + 2,
                         (TEXT_ARENA_Y_MIN + 2 + LCD_TEXT_HEIGHT), LCD_WHITE);

        LCD_PutChar(cursor.x, TEXT_ARENA_Y_MIN+2, character, LCD_TEXT_COLOR);
        cursor.x += LCD_TEXT_WIDTH + CURSOR_OFFSET;
    }
    else if (cursor.y < COMPOSE_MESSAGE_CURSOR_Y_MAX)       // if new-lines can be created
    {
        // create soft new-line (add vertical tab)
        message_data.message[current_message_index++] = VT;

        message_data.header_info.size_of_data++;    // increment number of bytes to send

        // place cursor at the beginning of next line
        cursor.x = COMPOSE_MESSAGE_CURSOR_X_MIN;
        cursor.y += LCD_TEXT_HEIGHT;

        // wipe current line of text arena
        LCD_DrawSection(section_text_arena,
                        (sizeof(section_text_arena)/sizeof(section_text_arena[0])));

        message_data.message[current_message_index++] = character;       // update current message

             // the only way to successfully write back a character after deleting a character
             // fucking beats Brit and I (QUESTION)
             LCD_DrawRectangle(cursor.x, (cursor.x + LCD_TEXT_WIDTH), TEXT_ARENA_Y_MIN+2,
                              (TEXT_ARENA_Y_MIN+2 + LCD_TEXT_HEIGHT), LCD_WHITE);

             LCD_PutChar(cursor.x+CURSOR_OFFSET, TEXT_ARENA_Y_MIN+2, character, LCD_TEXT_COLOR);
             cursor.x += LCD_TEXT_WIDTH + CURSOR_OFFSET;
    }
  //  G8RTOS_semaphore_signal(&semaphore_LCD);

    G8RTOS_semaphore_signal(&semaphore_cursor);

    return;
}

/************************************************************************************
* Name: insert_new_line
* Purpose: Helper function to insert a new line (carriage return followed by a line
*          feed) in currently composed message
* Output: N/A
************************************************************************************/
static inline void insert_new_line(void)
{
    G8RTOS_semaphore_wait(&semaphore_cursor);

    // IMPLEMENT: insert semaphore for cursor
    if (cursor.y < COMPOSE_MESSAGE_CURSOR_Y_MAX)
    {
        // insert carriage return and line feed into current message char array
        message_data.message[current_message_index++] = CR;
        message_data.message[current_message_index++] = LF;

        message_data.header_info.size_of_data += 2;    // increment number of bytes to send
     //   G8RTOS_semaphore_wait(&semaphore_LCD);

        // wipe current line of text arena
        LCD_DrawSection(section_text_arena,
                        (sizeof(section_text_arena)/sizeof(section_text_arena[0])));
      //  G8RTOS_semaphore_signal(&semaphore_LCD);

        cursor.x = COMPOSE_MESSAGE_CURSOR_X_MIN;
        cursor.y += LCD_TEXT_HEIGHT;
    }
    G8RTOS_semaphore_signal(&semaphore_cursor);

    return;
}

/************************************************************************************
* Name: delete_character
* Purpose: Helper function to delete an ASCII character from a given cursor position
* Input(s):
* Output: N/A
************************************************************************************/
static inline void delete_character()
{
    // IMPLEMENT: insert semaphore for cursor (for blinking)

    G8RTOS_semaphore_wait(&semaphore_cursor);

    // check if any previously typed characters exist
    if (cursor.x > COMPOSE_MESSAGE_CURSOR_X_MIN ||
        cursor.y > COMPOSE_MESSAGE_CURSOR_Y_MIN)
    {
        // erase previous character from text arena
        LCD_DrawRectangle((cursor.x - LCD_TEXT_WIDTH - CURSOR_OFFSET), (cursor.x + CURSOR_OFFSET), TEXT_ARENA_Y_MIN+2,
                          (TEXT_ARENA_Y_MIN+2 + LCD_TEXT_HEIGHT), LCD_WHITE);

        cursor.x -= (LCD_TEXT_WIDTH + CURSOR_OFFSET);

        /* check if previously entered character was new line (forced or vertical tab) */
        if ((message_data.message[current_message_index-1] == LF) ||     // guaranteed that LF follows CR
            (message_data.message[current_message_index-1] == VT))
        {
            if (message_data.message[current_message_index-1] == LF)
            {
                // remove forced new line
                message_data.message[--current_message_index] = 0x00;
                message_data.message[--current_message_index] = 0x00;

                message_data.header_info.size_of_data -= 2;    // decrement number of bytes to send by 2

            }
            else
            {
                // remove soft new line
                message_data.message[--current_message_index] = 0x00;
                message_data.header_info.size_of_data--;    // decrement number of bytes to send
            }

            /* display previous line of text on text arena */

            // place cursor at the beginning of previous line
            cursor.x = COMPOSE_MESSAGE_CURSOR_X_MIN;
            cursor.y -= LCD_TEXT_HEIGHT;

            /* two cases:
             * 1. the previous line either wrapped due to excessive characters (VT)
             * 2. the previous line wrapped due to a forced return (CR, LF)
             */

            uint16_t temp_index = current_message_index;        // used to traverse message

            // loop until one of the above mentioned cases are met
            while ((temp_index > 0) && (message_data.message[temp_index] != LF) && (message_data.message[temp_index] != VT))
            {
                temp_index--;
            }

            // handle edge case in which while loop above was broken by temp_index equaling 0
            if (temp_index > 0)
            {
                temp_index = temp_index + 1;        // this is to avoid printing out line feed or vertical tab
            }

            // print previous line of text
            for (uint16_t i = temp_index; i < current_message_index; i++)
            {
                // prevent LCD glitch
                LCD_DrawRectangle(cursor.x, (cursor.x + LCD_TEXT_WIDTH), TEXT_ARENA_Y_MIN+2,
                                 (TEXT_ARENA_Y_MIN+2 + LCD_TEXT_HEIGHT), LCD_WHITE);

                LCD_PutChar(cursor.x, TEXT_ARENA_Y_MIN+2, message_data.message[i], LCD_TEXT_COLOR);
                cursor.x += LCD_TEXT_WIDTH+CURSOR_OFFSET;
            }
        }
        else        // otherwise, erase single character from currently composed message
        {
            message_data.message[--current_message_index] = 0x00;
            message_data.header_info.size_of_data--;    // decrement number of bytes to send
        }
    }
    G8RTOS_semaphore_signal(&semaphore_cursor);

    return;
}

/************************************************************************************
* Name: send_message
* Purpose: Helper function to send message via wifi after touch is recognized on send message rectangle
* Input(s): Board_Type_t that defines who the message is meant to be sent to
* Output: N/A
* NOTE: This inline functions waits and signals semaphore_CC3100
************************************************************************************/
static inline void send_message(Board_Type_t board_type, Intended_Recipient_t contact)
{
    if(message_data.header_info.size_of_data == 0)
    {
        return;
    }

    uint32_t ip_address;

    if(contact == BRIT)
    {
        //BRIT WILL ALWAYS BE HOST
        //send message to host from client
         ip_address = HOST_IP_ADDR;
    }

    else if(contact == CHRIS)
    {
        //sending data from host to client
        ip_address = client1.IP_address; //CURRENTLY ONLY FOR FIRST CLIENT IMPLEMENT OTHER CLIENT LATER
    }


    // end message by appending ETX (end of text, 3)
    message_data.message[current_message_index] = 3;
    current_message_index++;
    message_data.header_info.size_of_data++;
    G8RTOS_semaphore_wait(&semaphore_CC3100);

    SendData((uint8_t*)&message_data.header_info, ip_address, sizeof(message_data.header_info)); //send header info
    SendData((uint8_t*)&message_data.to_and_from, ip_address, sizeof(message_data.to_and_from)); //send contact information (who I am trying to communicate with and who I am)
    SendData((uint8_t*)&message_data.message[0], ip_address, (message_data.header_info.size_of_data)); //send actual message

    G8RTOS_semaphore_signal(&semaphore_CC3100);

    // message has now been sent, need to update the global message log
    for(int i = 0; i < message_data.header_info.size_of_data; i++)
    {
        message_log[contact].message_history[message_log[contact].current_number_of_messages].old_message[i] = message_data.message[i];
    }

    // mark message as sent
    message_log[contact].message_history[message_log[contact].current_number_of_messages++].message_status = SENT;
    G8RTOS_semaphore_wait(&semaphore_LCD);

    // wipe current line of text arena
    LCD_DrawSection(section_text_arena,
                    (sizeof(section_text_arena)/sizeof(section_text_arena[0])));
    G8RTOS_semaphore_signal(&semaphore_LCD);

    //reset cursors
    G8RTOS_semaphore_wait(&semaphore_cursor);

    cursor.x = COMPOSE_MESSAGE_CURSOR_X_MIN;
    cursor.y = COMPOSE_MESSAGE_CURSOR_Y_MIN;
    G8RTOS_semaphore_signal(&semaphore_cursor);


    message_data.header_info.size_of_data = 0;
    for(int16_t i = current_message_index; i >= 0 ; i--)
    {
        message_data.message[i]=0; //reset array
    }

    current_message_index=0;

}

/************************************************************************************
* Name: print_messages_up
* Purpose: Helper function to print as many messages starting at and before
*          the passed-in index of the global message history array
* Input(s): IMPLEMENT: GLOBAL MESSAGE HISTORY PARAMETER, int *message_history_index
* Output: N/A
************************************************************************************/
static void print_messages_up(int *message_history_index)
{
    /* redraw text arena */
    LCD_DrawSection(section_message_log_text_arena,
                    (sizeof(section_message_log_text_arena)/sizeof(section_message_log_text_arena[0])));

    // variable to determine where to start printing message (from the bottom of the message)
    // initialize to bottom of screen
    uint8_t yPos = MESSAGE_LOG_TEXT_ARENA_Y_MAX - MESSAGE_LOG_MESSAGE_BOX_EDGE_OFFSET;

    Intended_Recipient_t contact;
    if(phone.self_contact == BRIT)
    {
        contact = CHRIS;
    }
    else if(phone.self_contact == CHRIS)
    {
        contact = BRIT;
    }
    /* print as many messages can fit on screen */
    while (*message_history_index >= 0)
    {
        char temp_char = NULL;
        uint16_t index = 0;
        uint8_t num_of_rows = 1;        // number of lines of text
        int max_row_length = -1;        // guarantee update at least once
        uint8_t current_row_length = 0;

        // traverse message to find longest line of characters (used to determine size of message)
        do
        {
            // read character from message
            //temp_char = message_array[*message_history_index][index++];
            temp_char = message_log[contact].message_history[*message_history_index].old_message[index++];
            if (temp_char != ETX && temp_char != 0)        // ignore end of text characters from message
            {
                if (temp_char == VT)      // soft new line encountered
                {
                    num_of_rows++;

                    // check if current line has greatest length so far
                    if (current_row_length > max_row_length)
                    {
                        max_row_length = current_row_length;
                    }

                    current_row_length = 0;     // reset current row length
                }
                else if (temp_char == CR)      // forced new line encountered
                {
                    index++;        // increment past LF
                    num_of_rows++;

                    // check if current line has greatest length so far
                    if (current_row_length > max_row_length)
                    {
                        max_row_length = current_row_length;
                    }

                    current_row_length = 0;     // reset current row length
                }
                else
                {
                    current_row_length++;       // increase number of characters encountered
                }
            }
        }while(temp_char != ETX);       // end of text encountered

        // if message was only one line or if last line was greatest length
        if ((max_row_length == -1) || (current_row_length > max_row_length))
        {
            max_row_length = current_row_length;
        }

        /* check if message can fit on screen */
        if ( (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT) -
            MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET - MESSAGE_LOG_MESSAGE_BOX_EDGE_OFFSET) < MESSAGE_LOG_TEXT_ARENA_Y_MIN )
        {
            break;      // message cannot fit, break for loop
        }

        /* draw either sent or sent message, based on who message belongs to (IMPLEMENT) */

          if(message_log[contact].message_history[*message_history_index].message_status == RECEIVED)
        {
            /* draw received message */
              G8RTOS_semaphore_wait(&semaphore_LCD);

            // draw black border around message
            LCD_DrawRectangle(MESSAGE_LOG_MESSAGE_BOX_RECEIVED_X_MIN,
                              ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 2) + MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET),
                              (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT) - MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET),
                              (yPos + MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET),
                              MESSAGE_LOG_MESSAGE_BOX_BORDER_COLOR);

            // draw received rectangle based on size of longest length line in text message
            LCD_DrawRectangle(MESSAGE_LOG_MESSAGE_BOX_RECEIVED_X_MIN,
                              ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 2)),
                              (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT)), yPos,
                              MESSAGE_LOG_MESSAGE_BOX_RECEIVED_COLOR);

            G8RTOS_semaphore_signal(&semaphore_LCD);

            index = 0;      // reset temporary index

            // initialize a cursor at beginning of received message box
            uint8_t x = MESSAGE_LOG_MESSAGE_RECEIVED_TEXT_X_MIN;      // used to print within message box
            uint8_t y = (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 1) - (num_of_rows * LCD_TEXT_HEIGHT));

            /* print message within received box */
            do
            {
                // read character from message
              //  temp_char = message_array[*message_history_index][index++];
                temp_char = message_log[contact].message_history[*message_history_index].old_message[index++];

                if (temp_char != ETX && temp_char != 0)        // ignore end of text characters from message
                {
                    if (temp_char == VT)    // soft new line encountered
                    {
                        x = MESSAGE_LOG_MESSAGE_RECEIVED_TEXT_X_MIN;        // set cursor to beginning of next line
                        y += LCD_TEXT_HEIGHT;
                    }
                    else if (temp_char == CR)     // forced new line encountered
                    {
                        index++;        // increment past LF

                        x = MESSAGE_LOG_MESSAGE_RECEIVED_TEXT_X_MIN;        // set cursor to beginning of next line
                        y += LCD_TEXT_HEIGHT;
                    }
                    else
                    {
                        G8RTOS_semaphore_wait(&semaphore_LCD);

                         LCD_PutChar(x, y, temp_char, MESSAGE_LOG_MESSAGE_TEXT_COLOR);       // place next character
                          x += LCD_TEXT_WIDTH;        // increment cursor position
                          G8RTOS_semaphore_signal(&semaphore_LCD);

                    }
                }

            }while(temp_char != ETX);       // end of text encountered

        }
        else        // if message was sent
        {

            /* draw sent message box */

            G8RTOS_semaphore_wait(&semaphore_LCD);

            // draw black border around message box
            LCD_DrawRectangle((MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX - ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 2) + MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET)),
                              MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX,
                              (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT) - MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET),
                              (yPos + MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET),
                              MESSAGE_LOG_MESSAGE_BOX_BORDER_COLOR);

            // draw sent rectangle based on size of longest length line in text message
            LCD_DrawRectangle((MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX - ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 2))),
                              MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX,
                              (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT)),
                              yPos,
                              MESSAGE_LOG_MESSAGE_BOX_SENT_COLOR);

            G8RTOS_semaphore_signal(&semaphore_LCD);


            index = 0;      // reset temporary index

            // IMPLEMENT depending on whether or not sent or sent

            // initialize a cursor at beginning of sent message box
            uint16_t x = (MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX - ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 1)));      // used to print within message box
            uint8_t y = (yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 1) - (num_of_rows * LCD_TEXT_HEIGHT));

            /* print message within sent box */
            do
            {
                // read character from message
               // temp_char = message_array[*message_history_index][index++];
                temp_char = message_log[contact].message_history[*message_history_index].old_message[index++];

                if (temp_char != ETX && temp_char != 0)        // ignore end of text characters from message
                {
                    if (temp_char == VT)    // soft new line encountered
                    {
                        x = (MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX - ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 1)));        // set cursor to beginning of next line
                        y += LCD_TEXT_HEIGHT;
                    }
                    else if (temp_char == CR)      // new line encountered
                    {
                        index++;        // increment past LF

                        x = (MESSAGE_LOG_MESSAGE_BOX_SENT_X_MAX - ((max_row_length * LCD_TEXT_WIDTH) + (MESSAGE_LOG_MESSAGE_TEXT_X_OFFSET * 1)));        // set cursor to beginning of next line
                        y += LCD_TEXT_HEIGHT;
                    }
                    else
                    {
                        G8RTOS_semaphore_wait(&semaphore_LCD);

                        LCD_PutChar(x, y, temp_char, MESSAGE_LOG_MESSAGE_TEXT_COLOR);       // place next character
                        x += LCD_TEXT_WIDTH;        // increment cursor position
                        G8RTOS_semaphore_signal(&semaphore_LCD);

                    }
                }
            }while(temp_char != ETX);       // end of text encountered
        }

        // update yPos to be at top of last printed message (bottom of next printable area)
        yPos = ((yPos - (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) - (num_of_rows * LCD_TEXT_HEIGHT) - MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET) - MESSAGE_LOG_MESSAGE_BOX_Y_OFFSET);

        if (((*message_history_index) - 1) < 0)
        {
            break;      // prevent edge case for indexing (save my ass for scrolling down)
        }
        else
        {
            // retrieve previous message on the next iteration
            (*message_history_index) = (*message_history_index) - 1;
        }
    }

    return;
}

/************************************************************************************
* Name: print_messages_down
* Purpose: Helper function to print as many messages starting at and after
*          the passed-in index of the global message history array
* Input(s): IMPLEMENT: GLOBAL MESSAGE HISTORY PARAMETER, int *message_history_index
* Output: N/A
************************************************************************************/
static void print_messages_down(int *message_history_index, uint8_t total_number_of_messages)
{
    // counter to store number of printable messages
    uint8_t number_of_printable_messages = 0;

    // temporary index used to traverse array
    int temp2_index = (*message_history_index);

    uint8_t yPos = MESSAGE_LOG_TEXT_ARENA_Y_MIN;


    Intended_Recipient_t contact;
    if(phone.self_contact == BRIT)
    {
        contact = CHRIS;
    }
    else if(phone.self_contact == CHRIS)
    {
        contact = BRIT;
    }

    // count how many messages can be printed top, down (same number as how many can be printed bottom, up)
    // guarantee no out-of-range indexing for message log
    while (temp2_index < total_number_of_messages - 1)
    {
        char temp_char = NULL;
        uint16_t index = 0;
        uint8_t num_of_rows = 1;        // number of lines of text
        int max_row_length = -1;        // guarantee update at least once
        uint8_t current_row_length = 0;

        // traverse message to find longest line of characters (used to determine size of message)
        do
        {
            // read character from message
            //temp_char = message_array[temp2_index][index++];
            temp_char = message_log[contact].message_history[temp2_index].old_message[index++];

            if (temp_char != ETX)        // ignore end of text characters from message
            {
                if (temp_char == VT)      // soft new line encountered
                {
                    num_of_rows++;

                    // check if current line has greatest length so far
                    if (current_row_length > max_row_length)
                    {
                        max_row_length = current_row_length;
                    }

                    current_row_length = 0;     // reset current row length
                }
                else if (temp_char == CR)      // forced new line encountered
                {
                    index++;        // increment past LF
                    num_of_rows++;

                    // check if current line has greatest length so far
                    if (current_row_length > max_row_length)
                    {
                        max_row_length = current_row_length;
                    }

                    current_row_length = 0;     // reset current row length
                }
                else
                {
                    current_row_length++;       // increase number of characters encountered
                }
            }
        }while(temp_char != ETX);       // end of text encountered

        // if message was only one line or if last line was greatest length
        if ((max_row_length == -1) || (current_row_length > max_row_length))
        {
            max_row_length = current_row_length;
        }

        /* check if message can fit on screen */
        if ( (yPos + (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) + (num_of_rows * LCD_TEXT_HEIGHT) +
            MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET + MESSAGE_LOG_MESSAGE_BOX_EDGE_OFFSET) > MESSAGE_LOG_TEXT_ARENA_Y_MAX )
        {
            break;      // message cannot fit, break for loop
        }
        else
        {
            // message can fit
            // set yPos at bottom of current message
            yPos = (yPos + (MESSAGE_LOG_MESSAGE_TEXT_Y_OFFSET * 2) + (num_of_rows * LCD_TEXT_HEIGHT) +
                   MESSAGE_LOG_MESSAGE_BOX_BORDER_OFFSET + MESSAGE_LOG_MESSAGE_BOX_EDGE_OFFSET);
        }

        temp2_index++;       // move to next message in message history
        number_of_printable_messages++;
    }

    /* increase message_history_index by that found number of messages to be printed (+1) */
    (*message_history_index) = (*message_history_index) + number_of_printable_messages + 2
            ;     // hacking into the mainframe

    /* print messages from bottom of screen, up */
    print_messages_up(message_history_index);       // message_history_index is already a pointer to an int


    return;
}


//////////////////////////////END OF PRIVATE FUNCTIONS///////////////////////////////

////////////////////////////////PUBLIC FUNCTIONS/////////////////////////////////////

/************************************************************************************
* Name:
* Purpose:
* Input(s):
* Output:
************************************************************************************/

/////////////////////////////END OF PUBLIC FUNCTIONS/////////////////////////////////

////////////////////////////////////THREADS//////////////////////////////////////////

/****************************** APERIODIC THREADS **********************************/

/************************************************************************************
 * Name: aperiodic_mumessage_compose_message
 * Purpose: Aperiodic event created after the initial display of the Compose Message
 *          screen within MuMessage. If a valid touch was made to the LCD TouchPanel,
 *          a thread for checking what section of the screen was pressed will be
 *          created.
 * Input(s): N/A
 * Output: N/A
 ***********************************************************************************/
void aperiodic_mumessage_compose_message(void)
{
    uint8_t status;     // used to identify which P4 pin triggered the ISR (pins 4 or 5)

    status = P4IV;      // P4IV = (2*(n+1)) where n is the pin number of the
                        // lowest bit with a pending interrupt.
                        // this access will only clear flag n.

    // if LCD TP triggered interrupt (port 4, pin 0)
    if (status == 2)        //  2 = 2*(0+2)
    {
        // disable pin 0 interrupt (will be rearmed after 0.5 seconds) (IMPLEMENT!)
        GPIO_disableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

        // create thread to check LCD screen press within Compose Message
        G8RTOS_add_thread(thread_mumessage_compose_message_check_TP, 50, "TP - compose mess.");
    }
}

/************************************************************************************
 * Name: aperiodic_mumessage_main_screen
 * Purpose: Aperiodic event created after the initial display of the main screen
 *          screen upon MuMessage opening. If a valid touch was made to the LCD TouchPanel,
 *          a thread for checking what section of the screen was pressed will be
 *          created.
 * Input(s): N/A
 * Output: N/A
 ***********************************************************************************/
void aperiodic_mumessage_main_screen(void)
{
    uint8_t status;     // used to identify which P4 pin triggered the ISR (pins 4 or 5)

    status = P4IV;      // P4IV = (2*(n+1)) where n is the pin number of the
                        // lowest bit with a pending interrupt.
                        // this access will only clear flag n.

    // if LCD TP triggered interrupt (port 4, pin 0)
    if (status == 2)        //  2 = 2*(0+2)
    {
        // disable pin 0 interrupt (will be rearmed after 0.5 seconds) (IMPLEMENT!)
        GPIO_disableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

        // create thread to check LCD screen press within Compose Message
        G8RTOS_add_thread(thread_mumessage_main_screen_check_TP, 50, "TP - MM main screen");
    }
}

/************************************************************************************
 * Name: aperiodic_mumessage_message_log
 * Purpose: Aperiodic event created after the initial display of the Message Log
 *          screen within MuMessage. If a valid touch was made to the LCD TouchPanel,
 *          a thread for checking what section of the screen was pressed will be
 *          created.
 * Input(s): N/A
 * Output: N/A
 ***********************************************************************************/
void aperiodic_mumessage_message_log(void)
{
    uint8_t status;     // used to identify which P4 pin triggered the ISR (pins 4 or 5)

    status = P4IV;      // P4IV = (2*(n+1)) where n is the pin number of the
                        // lowest bit with a pending interrupt.
                        // this access will only clear flag n.

    // if LCD TP triggered interrupt (port 4, pin 0)
    if (status == 2)        //  2 = 2*(0+2)
    {
        // disable pin 0 interrupt (will be rearmed after 0.5 seconds) (IMPLEMENT!)
        GPIO_disableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

        // create thread to check LCD screen press within Compose Message
        G8RTOS_add_thread(thread_mumessage_message_log_check_TP, 50, "TP - message log");
    }
}

/**************************** END OF APERIODIC THREADS *****************************/

/********************************* PERIODIC THREADS ********************************/

/************************************************************************************
* Name: periodic_cursor_blink
* Purpose: PET to blink cursor during compose message screen every 1 second
* Input(s): N/A
* Output: N/A
************************************************************************************/
void periodic_cursor_blink(void)
{
    periodic_threads_to_kill[0] = G8RTOS_get_pid();

    if(cursor_color == COMPOSE_MESSAGE_BACKGROUND_COLOR)
    {
        LCD_DrawRectangle(cursor.x, cursor.x+CURSOR_WIDTH, TEXT_ARENA_Y_MIN + 2, TEXT_ARENA_Y_MIN + 2 + CURSOR_HEIGHT, CURSOR_COLOR);
        cursor_color = CURSOR_COLOR;
    }
    else
    {
        LCD_DrawRectangle(cursor.x, cursor.x+CURSOR_WIDTH, TEXT_ARENA_Y_MIN + 2, TEXT_ARENA_Y_MIN + 2 + CURSOR_HEIGHT, COMPOSE_MESSAGE_BACKGROUND_COLOR);
         cursor_color = COMPOSE_MESSAGE_BACKGROUND_COLOR;
    }

}

/***************************** END OF PERIODIC THREADS *****************************/


/******************************* COMMON THREADS ************************************/

/* general threads */

/************************************************************************************
* Name: thread_mumessage_main_screen_check_TP
* Purpose: Thread to check if touch made to LCD TouchPanel interacted with any
*          predefined sections on the main screen of the MuMessage app.
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_main_screen_check_TP(void)
{
    // first debounce LCD
    G8RTOS_thread_sleep(TWO_TENTHS_SECOND_MS);

    // check if triggering switch is high after debounce time
    if ( P4->IN & PIN_TOUCHPANEL )
    {
         G8RTOS_kill_current_thread();     // thread improperly called
    }

    // otherwise, touch was properly made to TouchPanel LCD
    Point touch = TP_ReadXY();

    // index used to check for interaction between specific sections of screen
    int index = -1;

    // check for touch made to home screen application icons
    index = TP_CheckForSectionPress(touch, section_mumessage_main_screen_buttons,
                                    (sizeof(section_mumessage_main_screen_buttons)/sizeof(section_mumessage_main_screen_buttons[0])));

    // if touch made to LCD screen interacted with main screen choice
    if (index != -1)
    {
        G8RTOS_disable_aperiodic_thread(PORT4_IRQn);        // disable main screen aperiodic event

        if (index == COMPOSE_MESSAGE_BUTTON_INDEX)
        {
            G8RTOS_add_thread(thread_mumessage_compose_message, 100, "MM: compose message");
        }
        else if (index == MESSAGE_LOG_BUTTON_INDEX)
        {
            G8RTOS_add_thread(thread_mumessage_message_log, 100, "MM: message log");
        }
    }
    else        // otherwise, allow future touches to be made to LCD TP
    {
        // re-enable LCD Touch Panel interrupt and clear interrupt flag
        GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);
        GPIO_clearInterruptFlag(GPIO_PORT_P4, GPIO_PIN0);
    }

    // done handling TP touches, kill self
    G8RTOS_kill_current_thread();

}


/************************************************************************************
* Name: thread_mumessage_background_processes
* Purpose: Thread to initialize MuMessage background processes, including but not
*          limited to updating the MuPhone header bar with the current amount of
*          unread messages.
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_background_processes(void)
{
    /* initialize necessary data members */
    unread_message_count = 0;

    // local unread message count used to determine if anything needs to be updated
    uint16_t previous_unread_message_count = 0;

    // local string used to store entire unread message notification
    char unread_message_notification[4];

   // initialize unread_message_count_str with initial value


    // local Rectangle structure, used to wipe notifications
    Rectangle section_unread_message_notification_panel =
    {
      .xMin = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_PANEL_X_MIN, .xMax = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_PANEL_X_MAX,
      .yMin = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_PANEL_Y_MIN, .yMax = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_PANEL_Y_MAX,
      .color = MUPHONE_HEADER_BAR_COLOR
    };

    // local Rectangle structure, used to update notifications in header bar (used to print message box imagenotification)
    Rectangle section_unread_message_notification_icon =
    {
      .xMin = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MIN, .xMax = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MAX,
      .yMin = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MIN, .yMax = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MAX,
      .color = MUPHONE_HEADER_BAR_COLOR
    };

    // local Text structure, used to print notifications in header bar
    Text text_section_unread_message_notification =
    {
     .xStart = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_TEXT_X_START, .yStart = MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_TEXT_Y_START,
     .string = unread_message_notification, .color = MUPHONE_HEADER_BAR_IMPORTANT_NOTIFICATION_TEXT_COLOR
    };

    G8RTOS_semaphore_wait(&semaphore_LCD);

    // clear notification area
    LCD_DrawRectangleStructure(section_unread_message_notification_panel);

    // draw message notification icon
    LCD_DrawExtraSmallImage(MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MIN, MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MAX,
                            MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MIN, MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MAX, message_notification_icon_data);

    // hack into the mainframe
    LCD_DrawRectangle(MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MIN, MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_X_MIN + 1,
                      MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MIN, MUPHONE_HEADER_BAR_MESSAGE_NOTIFICATION_ICON_Y_MAX-5, MUPHONE_HEADER_BAR_COLOR);

    // print updated unread message notification
    LCD_PrintTextStructure(text_section_unread_message_notification);
    G8RTOS_semaphore_signal(&semaphore_LCD);

    while(1)
    {
        /* check if unread message notification needs to change */
        if (previous_unread_message_count != unread_message_count)
        {
            previous_unread_message_count = unread_message_count;       // update local count

            sprintf(unread_message_notification, "%u", previous_unread_message_count);


            // update local Text structure
            text_section_unread_message_notification.string = unread_message_notification;

            G8RTOS_semaphore_wait(&semaphore_LCD);

            // clear notification area
            LCD_DrawRectangleStructure(section_unread_message_notification_panel);


            G8RTOS_semaphore_signal(&semaphore_LCD);

            if ((previous_unread_message_count > 0))
            {
                // print updated unread message notification
                LCD_PrintTextStructure(text_section_unread_message_notification);
            }

        }

        // sleep notification checking for a second
        G8RTOS_thread_sleep(ONE_SECOND_MS);
    }
}

/* threads for Compose Message */


/************************************************************************************
* Name: thread_mumessage_message_log
* Purpose: Thread to draw message log screen
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_message_log(void)
{

    threads_to_kill[thread_mumessage_messagelog] = G8RTOS_get_tid();

    phone.current_app = MUMESSAGE_LOG;
    G8RTOS_semaphore_wait(&semaphore_LCD);

    // draw necessary screen visuals
    LCD_DrawSection(section_message_log_background,
                    (sizeof(section_message_log_background)/sizeof(section_message_log_background[0])));

    LCD_DrawSection(section_message_log_header,
                    (sizeof(section_message_log_header)/sizeof(section_message_log_header[0])));

    LCD_DrawSection(section_message_log_header_buttons,
                    (sizeof(section_message_log_header_buttons)/sizeof(section_message_log_header_buttons[0])));

    LCD_PrintTextSection(text_section_message_log_header,
                         (sizeof(text_section_message_log_header)/sizeof(text_section_message_log_header[0])));
    G8RTOS_semaphore_signal(&semaphore_LCD);

    // re-enable P4 interrupt
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

    Intended_Recipient_t contact;
    if(phone.board_type == BRIT)
    {
        contact = CHRIS;
    }
    else if(phone.board_type == CHRIS)
    {
        contact = BRIT;
    }

    /* add the necessary aperiodic thread for touches made to the LCD TouchPanel */
    G8RTOS_add_aperiodic_thread(aperiodic_mumessage_message_log, PORT4_IRQn, 6);

    int total_number_of_messages = message_log[contact].current_number_of_messages;     // IMPLEMENT: NUMBER OF MESSAGES IN CONTACT'S MESSAGE LOG
    int message_history_index = total_number_of_messages - 1;     // used to determine max index of message history

    /* print initial screen of message log (most current messages) */
    print_messages_up(&message_history_index);

    int temp_index = message_history_index;     // used to prevent unnecessary printing of messages

    // variables for reading joystick data
    int16_t xPos = 0;
    int16_t yPos = 0;

    unread_message_count=0; //no unread messages now

    /* read joystick every second to determine if screen should scroll to next page */
    while (1)
    {
        /* read joystick */
        GetJoystickCoordinates(&xPos, &yPos);

        if ((yPos > 100) && (temp_index < message_history_index))     // traverse down in message log
        {
            print_messages_down(&temp_index, total_number_of_messages);
        }
        else if ((yPos < -100) && (temp_index >= 0))        // traverse up in message log
        {
            print_messages_up(&temp_index);
        }

        if(message_received_in_log)
        {

            message_history_index = message_log[contact].current_number_of_messages-1;

            /* print initial screen of message log (most current messages) */
            print_messages_up(&message_history_index);
            temp_index = message_history_index;     // used to prevent unnecessary printing of messages

            message_received_in_log = false; //reset boolean
        }

        G8RTOS_thread_sleep(HALF_SECOND_MS);
    }
}

/************************************************************************************
* Name: thread_mumessage_message_log_check_TP
* Purpose: Thread to check if touch made to LCD TouchPanel interacted with any
*          predefined sections in the Compose Message screen of MuMessage.
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_message_log_check_TP(void)
{
    // otherwise, touch was properly made to TouchPanel LCD
    Point touch = TP_ReadXY();

    // first debounce LCD
    G8RTOS_thread_sleep(LCD_DEBOUNCE_TIME);

    // check if triggering switch is high after debounce time
    if ( P4->IN & PIN_TOUCHPANEL )
    {
         G8RTOS_kill_current_thread();     // thread improperly called
    }

    // index used to check for interaction between specific sections of screen
    int index = -1;


    // check if touch interacted with 'Back' button
    index = TP_CheckForSectionPress( touch, section_message_log_header_buttons,
                                     (sizeof(section_message_log_header_buttons)/sizeof(section_message_log_header_buttons[0])));


    // check if touch interacted with back button
    if (index == BACK_BUTTON_INDEX)
    {
        //IMPLEMENT
        // make sure to disable interrupts (?)

        G8RTOS_disable_aperiodic_thread(PORT4_IRQn); //disbale aperiodic thread to not write the screen again

        /* kill Message Log (IMPLEMENT) */
        kill_mumessage_threads();
        G8RTOS_semaphore_wait(&semaphore_LCD);

        LCD_DrawRectangle(cursor.x, (cursor.x + CURSOR_OFFSET), cursor.y, (cursor.y + CURSOR_HEIGHT), COMPOSE_MESSAGE_TEXT_ARENA_COLOR);
        G8RTOS_semaphore_signal(&semaphore_LCD);

        /* return to MuMessage main screen */
        G8RTOS_add_thread(thread_mumessage_open_app, 180, "MM: open app");

        G8RTOS_kill_current_thread();
    }

    // re-enable LCD Touch Panel interrupt and clear interrupt flag
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);
    GPIO_clearInterruptFlag(GPIO_PORT_P4, GPIO_PIN0);

    // kill thread (rip)
    G8RTOS_kill_current_thread();

}

/************************************************************************************
* Name: thread_mumessage_compose_message
* Purpose: Thread to draw Compose Message screen, and prepare for sending a
*          message to another MuPhone user.
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_compose_message(void)
{
    /* initialize necessary private data members */

    // initialize the global cursor to the beginning of the text arena
    cursor.x = COMPOSE_MESSAGE_CURSOR_X_MIN;
    cursor.y = COMPOSE_MESSAGE_CURSOR_Y_MIN;

    phone.current_app = MUMESSAGE_LOG;

    // initialize keyboard to keyboard #1 (keyboard = 0)
    keyboard = 0;

    /* draw Compose Message screen visuals */
    G8RTOS_semaphore_wait(&semaphore_LCD);

    LCD_DrawSection(section_compose_message_background,
                    (sizeof(section_compose_message_background)/sizeof(section_compose_message_background[0])));

    LCD_DrawSection(section_compose_message_header,
                    (sizeof(section_compose_message_header)/sizeof(section_compose_message_header[0])));

    LCD_DrawSection(section_compose_message_header_buttons,
                    (sizeof(section_compose_message_header_buttons)/sizeof(section_compose_message_header_buttons[0])));

    LCD_PrintTextSection(text_section_compose_message_header,
                           (sizeof(text_section_compose_message_header)/sizeof(text_section_compose_message_header[0])));

    LCD_DrawSection(section_text_arena,
                        (sizeof(section_text_arena)/sizeof(section_text_arena[0])));

    LCD_DrawSection(section_keyboard_background,
                    (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

    LCD_DrawSection(section_keyboard1_no_click,
                    (sizeof(section_keyboard1_no_click)/sizeof(section_keyboard1_no_click[0])));

    LCD_PrintTextSection(text_section_keyboard1_no_click,
                           (sizeof(text_section_keyboard1_no_click)/sizeof(text_section_keyboard1_no_click[0])));

    G8RTOS_semaphore_signal(&semaphore_LCD);

    message_data.header_info.intended_app = MUMESSAGE;
    message_data.header_info.size_of_data = 0;

    cursor_color =  COMPOSE_MESSAGE_BACKGROUND_COLOR;

    // re-enable P4 interrupt
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

    /* add the necessary aperiodic thread for touches made to the LCD TouchPanel */
    G8RTOS_add_aperiodic_thread(aperiodic_mumessage_compose_message, PORT4_IRQn, 6);

    /* add periodic thread for cursor blinking */
   //G8RTOS_add_pet(periodic_cursor_blink, FOUR_TENTHS_SECOND_MS, 0, "cursor blink");
    G8RTOS_add_thread(thread_blink_cursor, 40, "cursor blink");
    G8RTOS_kill_current_thread();

}

/************************************************************************************
* Name: thread_mumessage_compose_message_check_TP
* Purpose: Thread to check if touch made to LCD TouchPanel interacted with any
*          predefined sections in the Compose Message screen of MuMessage.
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_compose_message_check_TP(void)
{
    // otherwise, touch was properly made to TouchPanel LCD
    Point touch = TP_ReadXY();

    // first debounce LCD
    G8RTOS_thread_sleep(LCD_DEBOUNCE_TIME);

    // check if triggering switch is high after debounce time
    if ( P4->IN & PIN_TOUCHPANEL )
    {
         G8RTOS_kill_current_thread();     // thread improperly called
    }

    // index used to check for interaction between specific sections of screen
    int index = -1;

    // check if touch interacted with 'Send' button
    index = TP_CheckForSectionPress( touch, section_compose_message_header_buttons,
                                     (sizeof(section_compose_message_header_buttons)/sizeof(section_compose_message_header_buttons[0])));

    // check if touch interacted with back button (IMPLEMENT)
    if (index == BACK_BUTTON_INDEX)
    {
        G8RTOS_disable_aperiodic_thread(PORT4_IRQn); //disbale aperiodic thread to not write the screen again
        kill_mumessage_threads();

        G8RTOS_semaphore_wait(&semaphore_LCD);

        LCD_DrawRectangle(cursor.x, (cursor.x + CURSOR_OFFSET), cursor.y, (cursor.y + CURSOR_HEIGHT), COMPOSE_MESSAGE_TEXT_ARENA_COLOR);
        G8RTOS_semaphore_signal(&semaphore_LCD);

        /* return to MuMessage main screen */
        G8RTOS_add_thread(thread_mumessage_open_app, 180, "MM: open app");
        G8RTOS_kill_current_thread();
    }

    if (index == SEND_BUTTON_INDEX)     // send button was pressed
    {

        if(phone.self_contact == BRIT)
        {
            send_message(Client, message_data.to_and_from.contact);     //send data to client board (chris or wes)
            G8RTOS_thread_sleep(400);
        }
        else if(phone.self_contact == CHRIS)
        {
            send_message(Host, message_data.to_and_from.contact); //send data to host
            G8RTOS_thread_sleep(400);
        }
        else if(phone.self_contact == WES)
        {
            send_message(Host, message_data.to_and_from.contact); //send data to host
            G8RTOS_thread_sleep(400);
        }
    }
    if(kill_compose_message)
    {
        GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);
        GPIO_clearInterruptFlag(GPIO_PORT_P4, GPIO_PIN0);

        // kill thread (rip)
        G8RTOS_kill_current_thread();
        kill_compose_message = false;
    }
    // check if touch interacted with keyboard currently displayed
    G8RTOS_semaphore_wait(&semaphore_LCD);

    switch (keyboard)
    {
        case 0:     // check for interaction on keyboard #1 (lower-case keyboard)

            index = TP_CheckForSectionPress( touch, section_keyboard1_no_click,
                                             (sizeof(section_keyboard1_no_click)/sizeof(section_keyboard1_no_click[0])) );

            if (index != -1)        // if key was pressed
            {
                if (index == ALPHABET_KEYBOARD_CHANGE_CASE_INDEX)      // if upper-case/lower-case key was pressed
                {
                    keyboard = 1;       // update keyboard

                    // draw upper-case keyboard (keyboard #2)
                    LCD_DrawSection(section_keyboard2_no_click,
                                    (sizeof(section_keyboard2_no_click)/sizeof(section_keyboard2_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard2_no_click,
                                           (sizeof(text_section_keyboard2_no_click)/sizeof(text_section_keyboard2_no_click[0])));

                }
                else if (index == ALPHABET_KEYBOARD_BACKSPACE_INDEX)            // if backspace was pressed
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard1_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard1_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    delete_character();     // remove character based on current cursor position

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard1_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard1_no_click[index]);
                }
                else if (index == CHANGE_TO_NUMBERS_SYMBOLS_KEYBOARD_INDEX)     // if user wants to switch to numbers/symbols keyboards
                {
                    keyboard = 2;        // update keyboard

                    // draw keyboard #3
                    LCD_DrawSection(section_keyboard_background,
                                        (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                    LCD_DrawSection(section_keyboard3_no_click,
                                    (sizeof(section_keyboard3_no_click)/sizeof(section_keyboard3_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard3_no_click,
                                         (sizeof(text_section_keyboard3_no_click)/sizeof(text_section_keyboard3_no_click[0])));
                }
                else if (index == ALPHABET_KEYBOARD_RETURN_INDEX)       // if user wants to move to new line within text arena
                {
                    insert_new_line();
                }
                else        // otherwise, output respective ASCII character
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard1_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard1_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert character into text arena, based on current cursor position
                    insert_character(keyboard1_keys[index]);

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard1_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard1_no_click[index]);
                }
            }

            break;

        case 1:     // check for interaction on keyboard #2 (upper-case keyboard)

            index = TP_CheckForSectionPress( touch, section_keyboard2_no_click,
                                             (sizeof(section_keyboard2_no_click)/sizeof(section_keyboard2_no_click[0])) );

            if (index != -1)        // if key was pressed
            {
                if (index == ALPHABET_KEYBOARD_CHANGE_CASE_INDEX)      // if upper-case/lower-case key was pressed
                {
                    keyboard = 0;       // update keyboard

                    // draw lower-case keyboard (keyboard #1)

                    LCD_DrawSection(section_keyboard1_no_click,
                                    (sizeof(section_keyboard1_no_click)/sizeof(section_keyboard1_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard1_no_click,
                                           (sizeof(text_section_keyboard1_no_click)/sizeof(text_section_keyboard1_no_click[0])));

                }
                else if (index == ALPHABET_KEYBOARD_BACKSPACE_INDEX)            // if backspace was pressed
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard2_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard2_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    delete_character();     // remove character based on current cursor position

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard2_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard2_no_click[index]);
                }
                else if (index == CHANGE_TO_NUMBERS_SYMBOLS_KEYBOARD_INDEX)     // if user wants to switch to numbers/symbols keyboards
                {
                    keyboard = 2;        // update keyboard

                    // draw keyboard #3
                    LCD_DrawSection(section_keyboard_background,
                                        (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                    LCD_DrawSection(section_keyboard3_no_click,
                                    (sizeof(section_keyboard3_no_click)/sizeof(section_keyboard3_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard3_no_click,
                                         (sizeof(text_section_keyboard3_no_click)/sizeof(text_section_keyboard3_no_click[0])));

                }
                else if (index == ALPHABET_KEYBOARD_RETURN_INDEX)       // if user wants to move to new line within text arena
                {
                    insert_new_line();
                }
                else        // otherwise, output respective ASCII character
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard2_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard2_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert character into text arena, based on current cursor position
                    insert_character(keyboard2_keys[index]);

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard2_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard2_no_click[index]);
                }
            }

            break;

        case 2:     // check for interaction on keyboard #3 (numbers keyboard)

            index = TP_CheckForSectionPress( touch, section_keyboard3_no_click,
                                             (sizeof(section_keyboard3_no_click)/sizeof(section_keyboard3_no_click[0])) );

            if (index != -1)        // if key was pressed
            {
                if (index == NUMBERS_SYMBOLS_KEYBOARD_CHANGE_SYMBOLS_INDEX)      // if more symbols key was pressed
                {
                    keyboard = 3;       // update keyboard
                    // draw symbols keyboard (keyboard #4)
                    LCD_DrawSection(section_keyboard4_no_click,
                                    (sizeof(section_keyboard4_no_click)/sizeof(section_keyboard4_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard4_no_click,
                                           (sizeof(section_keyboard4_no_click)/sizeof(section_keyboard4_no_click[0])));

                }
                else if (index == NUMBERS_SYMBOLS_KEYBOARD_BACKSPACE_INDEX)            // if backspace was pressed
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard3_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_click[index]);

                    delete_character();     // remove character based on current cursor position

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard3_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_no_click[index]);
                }
                else if (index == CHANGE_TO_ALPHABET_KEYBOARD_INDEX)     // if user wants to switch to alphabet keyboards
                {
                    // determine which alphabet keyboard should be drawn
                    if (!lowercase_uppercase)
                    {
                        keyboard = 0;       // update keyboard

                        // draw lowercase keyboard (keyboard #1)
                        LCD_DrawSection(section_keyboard_background,
                                            (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                        LCD_DrawSection(section_keyboard1_no_click,
                                        (sizeof(section_keyboard1_no_click)/sizeof(section_keyboard1_no_click[0])));

                        LCD_PrintTextSection(text_section_keyboard1_no_click,
                                               (sizeof(text_section_keyboard1_no_click)/sizeof(text_section_keyboard1_no_click[0])));
                    }
                    else
                    {
                        keyboard = 1;       // update keyboard

                        // draw upper-case keyboard (keyboard #2)
                        LCD_DrawSection(section_keyboard_background,
                                            (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                        LCD_DrawSection(section_keyboard2_no_click,
                                        (sizeof(section_keyboard2_no_click)/sizeof(section_keyboard2_no_click[0])));

                        LCD_PrintTextSection(text_section_keyboard2_no_click,
                                               (sizeof(text_section_keyboard2_no_click)/sizeof(text_section_keyboard2_no_click[0])));
                    }
                }
                else if (index == NUMBERS_SYMBOLS_KEYBOARD_RETURN_INDEX)       // if user wants to move to new line within text arena
                {
                    insert_new_line();
                }
                else        // otherwise, output respective ASCII character
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard3_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert character into text arena, based on current cursor position
                    insert_character(keyboard3_keys[index]);

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard3_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_no_click[index]);
                }
            }

            break;

        case 3:     // check for interaction on keyboard #4 (symbols keyboard)

            index = TP_CheckForSectionPress( touch, section_keyboard4_no_click,
                                                         (sizeof(section_keyboard4_no_click)/sizeof(section_keyboard4_no_click[0])) );

            if (index != -1)        // if key was pressed
            {
                if (index == NUMBERS_SYMBOLS_KEYBOARD_CHANGE_SYMBOLS_INDEX)      // if numbers key was pressed
                {
                    keyboard = 2;       // update keyboard

                    // draw numbers keyboard (keyboard #3)
                    LCD_DrawSection(section_keyboard3_no_click,
                                    (sizeof(section_keyboard3_no_click)/sizeof(section_keyboard3_no_click[0])));

                    LCD_PrintTextSection(text_section_keyboard3_no_click,
                                           (sizeof(section_keyboard3_no_click)/sizeof(section_keyboard3_no_click[0])));

                }
                else if (index == NUMBERS_SYMBOLS_KEYBOARD_BACKSPACE_INDEX)            // if backspace was pressed
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard3_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_click[index]);

                    delete_character();     // remove character based on current cursor position

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard3_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard3_no_click[index]);
                }
                else if (index == HAPPY_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character(':');
                    insert_character(')');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == SAD_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character(':');
                    insert_character('(');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == WINKY_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character(';');
                    insert_character(')');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == MERP_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character(':');
                    insert_character('/');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == RAWR_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character('x');
                    insert_character('D');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == TONGUE_OUT_FACE_INDEX)
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert happy face ":)" into text arena, based on current cursor position
                    insert_character(':');
                    insert_character('P');

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
                else if (index == CHANGE_TO_ALPHABET_KEYBOARD_INDEX)     // if user wants to switch to alphabet keyboards
                {
                    // determine which alphabet keyboard should be drawn
                    if (!lowercase_uppercase)
                    {
                        keyboard = 0;       // update keyboard

                        // draw lowercase keyboard (keyboard #1)
                        LCD_DrawSection(section_keyboard_background,
                                            (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                        LCD_DrawSection(section_keyboard1_no_click,
                                        (sizeof(section_keyboard1_no_click)/sizeof(section_keyboard1_no_click[0])));

                        LCD_PrintTextSection(text_section_keyboard1_no_click,
                                               (sizeof(text_section_keyboard1_no_click)/sizeof(text_section_keyboard1_no_click[0])));
                    }
                    else
                    {
                        keyboard = 1;       // update keyboard

                        // draw upper-case keyboard (keyboard #2)
                        LCD_DrawSection(section_keyboard_background,
                                            (sizeof(section_keyboard_background)/sizeof(section_keyboard_background[0])));

                        LCD_DrawSection(section_keyboard2_no_click,
                                        (sizeof(section_keyboard2_no_click)/sizeof(section_keyboard2_no_click[0])));

                        LCD_PrintTextSection(text_section_keyboard2_no_click,
                                               (sizeof(text_section_keyboard2_no_click)/sizeof(text_section_keyboard2_no_click[0])));
                    }
                }
                else if (index == NUMBERS_SYMBOLS_KEYBOARD_RETURN_INDEX)       // if user wants to move to new line within text arena
                {
                    insert_new_line();
                }
                else        // otherwise, output respective ASCII character
                {
                    // show key was touched by redrawing key in specified color
                    LCD_DrawRectangleStructure(section_keyboard4_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_click[index]);

                    // wait for touch to be released before allowing other presses to be made to LCD TouchPanel
                    // IMPLEMENT: MAKE SURE OTHER IMPORTANT THREADS HAVE HIGHER PRIORITY DURING THIS WAITING PROCESS
                    TOUCHPANEL_WAIT();

                    // insert character into text arena, based on current cursor position
                    insert_character(keyboard4_keys[index]);

                    // redraw key in original color
                    LCD_DrawRectangleStructure(section_keyboard4_no_click[index]);
                    LCD_PrintTextStructure(text_section_keyboard4_no_click[index]);
                }
            }

            break;

        default:
            break;



    }
    G8RTOS_semaphore_signal(&semaphore_LCD);

    // re-enable LCD Touch Panel interrupt and clear interrupt flag
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);
    GPIO_clearInterruptFlag(GPIO_PORT_P4, GPIO_PIN0);

    // kill thread (rip)
    G8RTOS_kill_current_thread();
}
/************************************************************************************
* Name: thread_mumessage_open_app
* Purpose: Thread to open already initialized MuMessage application instance
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_open_app(void)
{
    G8RTOS_semaphore_wait(&semaphore_LCD);

    /* draw main screen */
    LCD_DrawSection(section_mumessage_main_screen,
                        (sizeof(section_mumessage_main_screen)/sizeof(section_mumessage_main_screen[0])));

    LCD_DrawSection(section_mumessage_main_screen_buttons,
                            (sizeof(section_mumessage_main_screen_buttons)/sizeof(section_mumessage_main_screen_buttons[0])));

    LCD_PrintTextSection(text_section_mumessage_main_screen,
                         (sizeof(text_section_mumessage_main_screen)/sizeof(text_section_mumessage_main_screen[0])));

    G8RTOS_semaphore_signal(&semaphore_LCD);

    // re-enable P4 interrupts to allow touches to be made to LCD TP
    GPIO_enableInterrupt(GPIO_PORT_P4, GPIO_PIN0);

    /* add aperiodic thread to detect touches made to the main screen */
    G8RTOS_add_aperiodic_thread(aperiodic_mumessage_main_screen, PORT4_IRQn, 6);


    if(phone.self_contact == BRIT)
    {
        message_data.to_and_from.contact = CHRIS; //talk to chris for now
        message_data.to_and_from.contact_of_sender = BRIT;

    }
    else if(phone.self_contact == CHRIS)
    {
        message_data.to_and_from.contact = BRIT; //talk to chris for now
        message_data.to_and_from.contact_of_sender = CHRIS;

    }
    G8RTOS_semaphore_init(&semaphore_cursor,1);

    phone.current_app = MUMESSAGE;
    G8RTOS_kill_current_thread();
}

/************************************************************************************
* Name: thread_mumessage_start_app
* Purpose: Thread to initialize MuMessage application as well as any necessary
*          application background processes
* Input(s): N/A
* Output: N/A
************************************************************************************/
void thread_mumessage_start_app(void)
{
    /* start main screen of MuMessage */

    G8RTOS_add_thread(thread_mumessage_open_app, 180, "MM: open app");
    phone.current_app = MUMESSAGE;      // set current app in phone (IMPLEMENT: DO THIS EVERYWHERE)

    G8RTOS_kill_current_thread();
}


//this thread is added when the intended app in the header byte is mumessage
void thread_receive_message_data()
{

    Contact_Data_t temp_contacts;
    char temp_buffer[MESSAGE_MAX_NUM_OF_CHARACTERS]; //temporary buffer to store received data before logging it into trusty ol' message
    G8RTOS_semaphore_wait(&semaphore_CC3100);

    ReceiveData((uint8_t*)&temp_contacts, sizeof(temp_contacts));
    ReceiveData((uint8_t*)&temp_buffer, phone.header_data.size_of_data);

    G8RTOS_semaphore_signal(&semaphore_CC3100);            //do something

    // update MuMessage's header byte info
    message_data.header_info.size_of_data = phone.header_data.size_of_data;


    // message has now been sent, need to update the global message log
    for(int i = 0; i < message_data.header_info.size_of_data; i++)
    {
        message_log[temp_contacts.contact_of_sender].message_history[message_log[temp_contacts.contact_of_sender].current_number_of_messages].old_message[i] = temp_buffer[i];
    }


    // mark message as received
    message_log[temp_contacts.contact_of_sender].message_history[message_log[temp_contacts.contact_of_sender].current_number_of_messages++].message_status = RECEIVED;

    unread_message_count++;     // TESTING new message notification, need to reset if click on message log

    if(phone.current_app == MUMESSAGE_LOG)
    {
        message_received_in_log = true;
        unread_message_count--;
    }


    G8RTOS_kill_current_thread(); //kill thread
}

void thread_blink_cursor()
{
    threads_to_kill[CURSOR] = G8RTOS_get_tid();

    while(1)
    {
        G8RTOS_semaphore_wait(&semaphore_LCD);
        G8RTOS_semaphore_wait(&semaphore_cursor);

        if(cursor_color == COMPOSE_MESSAGE_BACKGROUND_COLOR)
        {
            LCD_DrawRectangle(cursor.x, cursor.x+CURSOR_WIDTH, TEXT_ARENA_Y_MIN + 2, TEXT_ARENA_Y_MIN + 2 + CURSOR_HEIGHT, CURSOR_COLOR);
            cursor_color = CURSOR_COLOR;
        }
        else
        {
            LCD_DrawRectangle(cursor.x, cursor.x+CURSOR_WIDTH, TEXT_ARENA_Y_MIN + 2, TEXT_ARENA_Y_MIN + 2 + CURSOR_HEIGHT, COMPOSE_MESSAGE_BACKGROUND_COLOR);
             cursor_color = COMPOSE_MESSAGE_BACKGROUND_COLOR;
        }
        G8RTOS_semaphore_signal(&semaphore_cursor);
        G8RTOS_semaphore_signal(&semaphore_LCD);

        G8RTOS_thread_sleep(750);

    }


}
/**************************** END OF COMMON THREADS ********************************/


/******************************** HOST THREADS *************************************/

/***************************** END OF HOST THREADS *********************************/


/******************************* CLIENT THREADS ************************************/

/**************************** END OF CLIENT THREADS ********************************/


/////////////////////////////////END OF THREADS//////////////////////////////////////



////////////////////////////INTERRUPT SERVICE ROUTINES///////////////////////////////
////////////////////////END OF INTERRUPT SERVICE ROUTINES////////////////////////////

////////////////////////////////END OF mumessage.c////////////////////////////////////
